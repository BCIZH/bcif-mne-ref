# 预处理功能对比: MNE-Python vs Brainstorm3

> **专题**: 信号预处理算法与工作流对比  
> **更新**: 2026年1月31日

---

## 目录

1. [滤波算法](#滤波算法)
2. [伪迹去除](#伪迹去除)
3. [重参考](#重参考)
4. [坏通道处理](#坏通道处理)
5. [重采样与裁剪](#重采样与裁剪)
6. [工作流对比](#工作流对比)

---

## 滤波算法

### 相同点: 核心算法一致

两者都基于 **Parks-McClellan 最优FIR设计** 和 **零相位滤波**

---

### MNE-Python: raw.filter()

**实现位置**: `mne/filter.py` (2000+ 行)

```python
# 基本用法
raw.filter(l_freq=1.0, h_freq=40.0, method='fir', phase='zero')

# 参数详解
raw.filter(
    l_freq=1.0,              # 高通截止 (Hz) - None表示不高通
    h_freq=40.0,             # 低通截止 (Hz) - None表示不低通
    picks=None,              # 通道选择
    filter_length='auto',    # FIR长度 (样本数)
    l_trans_bandwidth='auto', # 高通过渡带
    h_trans_bandwidth='auto', # 低通过渡带
    n_jobs=1,                # 并行核心数
    method='fir',            # 'fir' | 'iir'
    iir_params=None,         # IIR参数 (Butterworth等)
    phase='zero',            # 'zero' | 'minimum' | 'zero-double'
    fir_window='hamming',    # FIR窗函数
    fir_design='firwin',     # 'firwin' | 'firwin2'
    pad='reflect_limited',   # 边缘填充方式
    verbose=None
)
```

**算法细节**:

1. **FIR滤波器设计** (`firwin` method):
```python
from scipy.signal import firwin, filtfilt

# 自动计算过渡带
if l_trans_bandwidth == 'auto':
    l_trans_bandwidth = min(max(0.25 * l_freq, 2), l_freq)

# 计算滤波器长度
filter_length = estimate_filter_length(
    l_freq, h_freq, sfreq, 
    l_trans_bandwidth, h_trans_bandwidth
)

# 设计FIR系数
fir_coeffs = firwin(
    filter_length,
    [l_freq, h_freq],
    window='hamming',
    pass_zero=False,  # 带通
    fs=sfreq
)

# 零相位滤波 (前向-后向)
filtered = filtfilt(fir_coeffs, 1.0, data)
```

2. **IIR滤波器** (Butterworth):
```python
from scipy.signal import butter, sosfiltfilt

# 设计
sos = butter(
    N=5,                    # 阶数
    Wn=[l_freq, h_freq],
    btype='bandpass',
    output='sos',
    fs=sfreq
)

# 零相位滤波
filtered = sosfiltfilt(sos, data)
```

**优势**:
- ✅ 自动参数优化 (`'auto'` 模式)
- ✅ 灵活的窗函数选择
- ✅ 并行处理支持 (`n_jobs`)
- ✅ 多种相位选项 (因果/非因果)
- ✅ 实时友好 (`phase='minimum'`)

**代码示例**:
```python
import mne

# 示例1: 标准带通
raw = mne.io.read_raw_fif('data.fif', preload=True)
raw.filter(l_freq=1.0, h_freq=40.0)

# 示例2: 只高通 (去漂移)
raw.filter(l_freq=0.5, h_freq=None)

# 示例3: 只低通 (平滑)
raw.filter(l_freq=None, h_freq=100.0)

# 示例4: 实时因果滤波
raw.filter(1.0, 40.0, phase='minimum')  # 用于实时系统

# 示例5: 多核加速
raw.filter(1.0, 40.0, n_jobs=4)

# 示例6: IIR滤波 (计算更快)
raw.filter(1.0, 40.0, method='iir', iir_params={'order': 5, 'ftype': 'butter'})
```

---

### Brainstorm3: process_bandpass.m

**实现位置**: `toolbox/process/functions/process_bandpass.m`

```matlab
% GUI操作:
% Process > Pre-process > Band-pass filter

% 脚本调用:
sFiles = bst_process('CallProcess', 'process_bandpass', sFiles, [], ...
    'sensortypes', 'MEG, EEG', ...
    'highpass',    1.0, ...        % 高通截止
    'lowpass',     40.0, ...       % 低通截止
    'tranband',    0, ...          % 过渡带 (0=自动)
    'attenuation', 'strict', ...   % 'strict' (60dB) | 'relax' (40dB)
    'ver',         '2019', ...     % 滤波器版本
    'mirror',      0, ...          % 镜像边缘 (0=否)
    'read_all',    0);             % 分块处理
```

**算法细节** (与MNE基本相同):

```matlab
function [x, FiltSpec] = Compute(x, sfreq, HighPass, LowPass, ...)
    % 1. 计算过渡带 (自动)
    if (tranband == 0)
        if (HighPass > 0)
            tranband = 0.5 * HighPass;
        else
            tranband = 0.5 * LowPass;
        end
    end
    
    % 2. 设计Parks-McClellan FIR
    if strcmp(ver, '2019')
        % bst-hfilter-2019 (推荐)
        f = [0, HighPass-tranband, HighPass, LowPass, ...
             LowPass+tranband, sfreq/2] / (sfreq/2);
        a = [0, 0, 1, 1, 0, 0];        % 理想增益
        dev = [0.001, 0.001, 0.001];   % 容差
        
        [n, fo, ao, w] = firpmord(f, a, dev);
        b = firpm(n, fo, ao, w);       % Parks-McClellan设计
    end
    
    % 3. 零相位滤波 (filtfilt)
    x = filtfilt(b, 1, x);
end
```

**参数对比**:

| 参数 | MNE-Python | Brainstorm3 |
|------|------------|-------------|
| **高通截止** | `l_freq` | `highpass` |
| **低通截止** | `h_freq` | `lowpass` |
| **过渡带** | `l/h_trans_bandwidth` | `tranband` |
| **阻带衰减** | 固定60dB | 可选60dB/40dB |
| **滤波器版本** | 自动最新 | 可选2019/2016/FFT |
| **窗函数** | 可配置 | 固定Parks-McClellan |
| **并行** | `n_jobs` | 不支持 |

**优势**:
- ✅ GUI友好参数
- ✅ 历史版本兼容
- ✅ 阻带衰减可选

---

## 伪迹去除

### 相同点: ICA 算法

两者都支持 **FastICA** 和 **Infomax** 算法

---

### MNE-Python: ICA类

**实现位置**: `mne/preprocessing/ica.py` (3000+ 行)

```python
from mne.preprocessing import ICA

# 1. 创建ICA对象
ica = ICA(
    n_components=20,           # 成分数 (None=自动)
    max_pca_components=None,   # PCA预降维
    n_pca_components=None,     # 保留的PCA成分
    noise_cov=None,            # 噪声协方差 (白化用)
    random_state=97,           # 随机种子
    method='fastica',          # 'fastica' | 'infomax' | 'picard'
    fit_params=None,           # 算法参数
    max_iter=200,              # 最大迭代次数
    allow_ref_meg=False        # 是否包含参考通道
)

# 2. 拟合 (学习混合矩阵)
ica.fit(raw, picks='eeg', decim=3, reject=dict(eeg=100e-6))

# 3. 可视化成分
ica.plot_sources(raw)          # 时间序列
ica.plot_components()          # 拓扑图
ica.plot_properties(raw, picks=[0, 1, 2])  # 详细分析

# 4. 手动选择坏成分
ica.exclude = [0, 2]  # 眼电、心电成分

# 5. 应用 (移除坏成分)
ica.apply(raw)

# 6. 保存/加载
ica.save('ica-sol.fif')
ica = mne.preprocessing.read_ica('ica-sol.fif')
```

**自动检测伪迹**:

```python
# EOG检测
eog_indices, eog_scores = ica.find_bads_eog(
    raw, 
    ch_name='EOG 061',  # EOG通道
    threshold=3.0       # Z-score阈值
)
ica.exclude.extend(eog_indices)

# ECG检测
ecg_indices, ecg_scores = ica.find_bads_ecg(
    raw,
    method='correlation',
    threshold='auto'
)
ica.exclude.extend(ecg_indices)

# 肌电检测 (高频活动)
muscle_idx, scores = ica.find_bads_muscle(raw)
```

**算法细节**:

```python
# FastICA (默认)
from sklearn.decomposition import FastICA

# 1. PCA降维
pca = PCA(n_components=n_pca_components)
data_pca = pca.fit_transform(data.T).T

# 2. FastICA分解
fastica = FastICA(
    n_components=n_components,
    algorithm='parallel',  # 'parallel' | 'deflation'
    whiten=False,          # 已经PCA白化
    fun='logcosh',         # 对比函数
    max_iter=200,
    random_state=random_state
)
sources = fastica.fit_transform(data_pca.T).T

# 3. 混合矩阵
mixing_matrix = pca.components_.T @ fastica.mixing_
unmixing_matrix = fastica.components_ @ pca.components_
```

---

### Brainstorm3: ICA进程

**实现位置**: `toolbox/process/functions/process_ica.m`

```matlab
% GUI操作:
% Process > Artifacts > ICA components

% 脚本调用:
sFiles = bst_process('CallProcess', 'process_ica', sFiles, [], ...
    'timewindow',  [], ...           % 时间窗口 (空=全部)
    'eventname',   '', ...           % 事件名称
    'eventtime',   [], ...           % 事件时间
    'bandpass',    [0, 0], ...       % 预滤波
    'nicacomp',    20, ...           % ICA成分数
    'icasort',     1, ...            % ICA排序方法
    'usessp',      1, ...            % 使用SSP
    'ignorebad',   1);               % 忽略坏通道

% 查看成分
panel_ica('DisplayComponents', IcaFile);

% 移除成分 (GUI交互)
% 右键成分 > Remove component

% 应用清洗
sFiles = bst_process('CallProcess', 'process_ica_apply', sFiles);
```

**算法实现**:

```matlab
function [IcaComponents, IcaWeights] = Compute(F, nComp)
    % 使用EEGLAB的runica (Infomax)
    
    % 1. 调用EEGLAB
    [IcaWeights, sphere] = runica(F, ...
        'ncomps', nComp, ...
        'extended', 1, ...       % Extended Infomax
        'maxsteps', 512);
    
    % 2. 计算源信号
    IcaComponents = IcaWeights * sphere * F;
    
    % 3. 计算混合矩阵
    IcaInvWeights = pinv(IcaWeights * sphere);
end
```

**特色功能**:

1. **ICA地图分类** (自动标注):
```matlab
% 基于ICLabel深度学习模型
% 分类: Brain, Muscle, Eye, Heart, Line Noise, Channel Noise, Other

% MNE-ICALabel也支持相同功能!
from mne_icalabel import label_components
labels = label_components(raw, ica, method='iclabel')
```

2. **ECG/EOG自动检测**:
```matlab
% 检测心跳成分
sFiles = bst_process('CallProcess', 'process_ica_detect', sFiles, [], ...
    'eventtype', 'cardiac');

% 检测眼动成分  
sFiles = bst_process('CallProcess', 'process_ica_detect', sFiles, [], ...
    'eventtype', 'blink');
```

---

### SSP投影 (共享算法)

**MNE-Python**:
```python
# 1. 计算SSP投影算子
projs_ecg, _ = mne.preprocessing.compute_proj_ecg(
    raw, n_grad=1, n_mag=1, n_eeg=1
)
projs_eog, _ = mne.preprocessing.compute_proj_eog(
    raw, n_grad=1, n_mag=1, n_eeg=1
)

# 2. 添加到数据
raw.add_proj(projs_ecg)
raw.add_proj(projs_eog)

# 3. 应用投影
raw.apply_proj()

# 4. 可视化
mne.viz.plot_projs_topomap(projs_ecg, raw.info)
```

**Brainstorm3**:
```matlab
% GUI: Process > Artifacts > SSP: Cardiac

sFiles = bst_process('CallProcess', 'process_ssp_ecg', sFiles, [], ...
    'eventname',   'cardiac', ...
    'sensortypes', 'MEG MAG', ...
    'usessp',      1, ...
    'select',      1);  % 自动选择成分数
```

---

## 重参考

### MNE-Python: set_eeg_reference()

```python
# 1. 平均参考 (推荐用于密集阵列)
raw.set_eeg_reference('average', projection=True)

# 2. 指定参考通道
raw.set_eeg_reference(ref_channels=['Cz'])

# 3. 双侧乳突平均
raw.set_eeg_reference(ref_channels=['M1', 'M2'])

# 4. REST参考 (需要头模型)
sphere = mne.make_sphere_model('auto', 'auto', raw.info)
raw.set_eeg_reference('REST', forward=sphere)

# 5. 移除已存在的参考
raw.set_eeg_reference([])  # 转换为无参考状态
```

**算法**:
```python
# 平均参考实现
def set_average_reference(data):
    """
    data: [n_channels × n_times]
    """
    mean_signal = data.mean(axis=0, keepdims=True)  # [1 × n_times]
    data_reref = data - mean_signal                 # 广播减法
    return data_reref
```

---

### Brainstorm3: process_eegref()

```matlab
% GUI: Process > Standardize > Re-reference EEG

sFiles = bst_process('CallProcess', 'process_eegref', sFiles, [], ...
    'eegref',      'AVERAGE', ...  % 'AVERAGE' | channel names
    'sensortypes', 'EEG');

% 其他选项:
% 'eegref', 'Cz'           % 单个通道
% 'eegref', 'M1, M2'       % 多通道平均
```

---

## 坏通道处理

### MNE-Python

```python
# 1. 手动标记
raw.info['bads'] = ['MEG 0113', 'EEG 053']

# 2. 自动检测 (基于统计)
from mne.preprocessing import find_bad_channels_maxwell
raw_check = raw.copy()
noisy_chs, flat_chs, scores = find_bad_channels_maxwell(
    raw_check, 
    cross_talk=ct_sparse, 
    calibration=sss_cal
)
raw.info['bads'].extend(noisy_chs + flat_chs)

# 3. 插值修复
raw.interpolate_bads(reset_bads=True)

# 4. 可视化检查
raw.plot(bad_color='red')  # 坏通道显示为红色
```

**插值算法**:
```python
# 球面样条插值 (Perrin 1989)
from mne.channels.interpolation import _make_interpolation_matrix

# 基于通道位置计算插值矩阵
interp_mat = _make_interpolation_matrix(
    good_channels_pos,  # 好通道位置
    bad_channels_pos,   # 坏通道位置
    method='spline'     # 球面样条
)

# 插值
data[bad_idx, :] = interp_mat @ data[good_idx, :]
```

---

### Brainstorm3

```matlab
% 1. 手动标记 (GUI)
% 时间序列图 > 右键通道 > Mark as bad

% 2. 插值
sFiles = bst_process('CallProcess', 'process_eeg_interpbad', sFiles, [], ...
    'sensortypes', 'EEG', ...
    'method',      'spline');  % 'spline' | 'average'
```

---

## 重采样与裁剪

### 相同点: 基于scipy.signal

**MNE-Python**:
```python
# 重采样
raw.resample(sfreq=250, npad='auto', n_jobs=4)

# 裁剪
raw.crop(tmin=10, tmax=60)  # 保留10-60秒

# 组合
raw.resample(250).crop(10, 60)
```

**算法**:
```python
from scipy.signal import resample_poly

# 多相重采样 (高质量)
data_resampled = resample_poly(
    data, 
    up=new_sfreq,      # 上采样因子
    down=old_sfreq,    # 下采样因子
    axis=-1,           # 时间轴
    padtype='reflect'
)
```

**Brainstorm3**:
```matlab
% 重采样
sFiles = bst_process('CallProcess', 'process_resample', sFiles, [], ...
    'freq',     250, ...
    'read_all', 0);

% 裁剪
sFiles = bst_process('CallProcess', 'process_extract_time', sFiles, [], ...
    'timewindow', [10, 60], ...
    'overwrite', 1);
```

---

## 工作流对比

### 完整预处理示例

#### MNE-Python (脚本驱动)

```python
import mne
from mne.preprocessing import ICA

# ========================================
# 完整预处理流程 (约30行代码)
# ========================================

# 1. 加载数据
raw = mne.io.read_raw_fif('raw.fif', preload=True)

# 2. 标记坏通道 (手动或自动)
raw.info['bads'] = ['MEG 0113', 'MEG 0112']

# 3. 滤波
raw.filter(l_freq=1.0, h_freq=40.0, n_jobs=4)

# 4. 重参考 (EEG)
raw.set_eeg_reference('average', projection=True)

# 5. ICA伪迹去除
ica = ICA(n_components=20, method='fastica', random_state=97)
ica.fit(raw, picks='eeg', decim=3)

# 自动检测EOG/ECG
eog_idx, _ = ica.find_bads_eog(raw, ch_name='EOG 061')
ecg_idx, _ = ica.find_bads_ecg(raw)
ica.exclude = eog_idx + ecg_idx

# 应用ICA
ica.apply(raw)

# 6. 插值坏通道
raw.interpolate_bads(reset_bads=True)

# 7. 重采样
raw.resample(250)

# 8. 保存
raw.save('cleaned_raw.fif', overwrite=True)

print("预处理完成!")
```

**批量处理** (100个受试者):
```python
subjects = ['S001', 'S002', ..., 'S100']

for subject in subjects:
    raw = mne.io.read_raw_fif(f'{subject}_raw.fif', preload=True)
    
    # 预处理步骤...
    raw.filter(1, 40).set_eeg_reference('average')
    ica.fit(raw)
    # ...
    
    raw.save(f'{subject}_clean.fif')
```

---

#### Brainstorm3 (GUI驱动)

```
GUI操作流程 (约15-20次点击):

1. [File > Import data]
   - 选择文件
   
2. [右键数据 > Mark channels as bad]
   - 点击通道列表标记

3. [Process > Pre-process > Band-pass filter]
   - 输入: 1-40 Hz
   - Run
   
4. [Process > Standardize > Re-reference EEG]
   - 选择: Average
   - Run

5. [Process > Artifacts > ICA components]
   - 成分数: 20
   - Run
   
6. [双击ICA结果 > 查看成分]
   - 右键坏成分 > Remove
   
7. [Process > Artifacts > Apply ICA]
   - Run

8. [Process > Pre-process > Interpolate bad channels]
   - Run

9. [Process > Pre-process > Resample]
   - 250 Hz
   - Run
```

**批处理脚本**:
```matlab
% Brainstorm批处理
sFiles = [];

% 循环处理
for i = 1:100
    % 导入
    sFiles = bst_process('CallProcess', 'process_import_data_raw', ...
        [], [], 'subjectname', sprintf('S%03d', i));
    
    % 滤波
    sFiles = bst_process('CallProcess', 'process_bandpass', ...
        sFiles, [], 'highpass', 1, 'lowpass', 40);
    
    % 重参考
    sFiles = bst_process('CallProcess', 'process_eegref', ...
        sFiles, [], 'eegref', 'AVERAGE');
    
    % ICA
    sFiles = bst_process('CallProcess', 'process_ica', ...
        sFiles, [], 'nicacomp', 20);
    
    % ... 其他步骤
end
```

---

## 功能对比总结

| 功能 | MNE-Python | Brainstorm3 | 算法一致性 |
|------|------------|-------------|-----------|
| **FIR滤波** | ✅ 高度可配置 | ✅ GUI友好 | ✅ 相同 (Parks-McClellan) |
| **IIR滤波** | ✅ 支持 | ❌ 不支持 | - |
| **ICA** | ✅ FastICA/Infomax/Picard | ✅ Infomax (EEGLAB) | ✅ 基本相同 |
| **SSP投影** | ✅ 完整支持 | ✅ 完整支持 | ✅ 相同 |
| **坏通道插值** | ✅ 球面样条 | ✅ 球面样条/平均 | ✅ 相同 |
| **重参考** | ✅ 多种方式 (含REST) | ✅ 平均/指定通道 | ⚖️ MNE更多选项 |
| **重采样** | ✅ 多相+并行 | ✅ 标准重采样 | ✅ 相同 (scipy) |
| **自动化** | ⭐⭐⭐⭐⭐ 脚本化 | ⭐⭐⭐ GUI+脚本 | - |
| **批量处理** | ⭐⭐⭐⭐⭐ 原生并行 | ⭐⭐⭐ 需循环 | - |
| **实时处理** | ⭐⭐⭐⭐ 支持 (minimum phase) | ❌ 不支持 | - |

---

## 各自优势

### MNE-Python 预处理优势

1. ✅ **高度自动化**: 一行代码完成多步操作
2. ✅ **并行加速**: `n_jobs` 参数无缝多核
3. ✅ **实时友好**: `phase='minimum'` 因果滤波
4. ✅ **灵活配置**: 每个参数都可调
5. ✅ **链式操作**: `raw.filter().resample().crop()`
6. ✅ **批量处理**: Python循环 + 并行库

---

### Brainstorm3 预处理优势

1. ✅ **GUI可视化**: 每步都能实时查看
2. ✅ **交互式**: 手动调整参数立即看到效果
3. ✅ **历史追踪**: 自动记录所有操作
4. ✅ **教学友好**: 步骤清晰,概念直观
5. ✅ **无需编程**: 点击即可完成

---

## 选择建议

**选择 MNE-Python** 如果:
- 需要处理 **大量受试者** (自动化)
- 需要 **自定义算法** (灵活性)
- 需要 **实时处理** (BCI应用)
- 熟悉 **Python编程**

**选择 Brainstorm3** 如果:
- **单个受试者** 探索性分析
- **教学演示** (可视化友好)
- **不熟悉编程** (GUI操作)
- 需要 **交互式调参**

**两者结合**:
```
Brainstorm GUI探索 → 确定参数 → MNE脚本批量处理
```

核心算法一致,只是操作方式不同! 🎯
