# Brainstorm3 机器学习与高级分析算法详解

## 概述

Brainstorm3集成了机器学习方法用于脑信号解码、分类和模式识别。本文档涵盖解码算法、spike sorting、特征提取等高级分析技术。

## 1. 解码与分类

### 1.1 SVM解码 (process_decoding_svm.m)

**支持向量机（Support Vector Machine）分类器**

**原理：**
找到最优超平面分离不同条件的试次
```matlab
% 线性SVM决策函数
f(x) = w'*x + b

% 优化目标
min (1/2)||w||² + C*Σξ_i
subject to: y_i(w'*x_i + b) >= 1 - ξ_i
```

**使用场景：**
```matlab
% 二分类解码（如：face vs house）
sFiles = bst_process('CallProcess', 'process_decoding_svm', sFiles, [], ...
    'sensortypes',       'MEG', ...
    'ignorebad',         1, ...
    'lowpass',           30, ...           % 低通滤波
    'num_permutations',  100, ...          % 置换次数
    'kfold',             5, ...            % 交叉验证折数
    'method',            1);               % 1=Pairwise, 2=Temporal gen

% 输出：解码准确率时间序列
```

**解码方法：**

**1. Pairwise（成对）：**
- 两两条件对比
- 输出：每对的解码准确率

**2. Temporal Generalization（时间泛化）：**
```matlab
% 训练分类器在时间t1
% 测试在所有时间点t2
Accuracy(t_train, t_test) = test(model_trained_at_t_train, data_at_t_test)

% 输出：时间×时间矩阵
% 对角线：标准解码
% 非对角线：泛化能力
```

**应用示例：**
```matlab
% 检验P300分类器
sFiles_target = bst_process('CallProcess', 'process_select_tag', sFiles, [], ...
    'tag', 'target');
sFiles_standard = bst_process('CallProcess', 'process_select_tag', sFiles, [], ...
    'tag', 'standard');

sFiles_all = [sFiles_target, sFiles_standard];

% SVM解码
sFiles_decode = bst_process('CallProcess', 'process_decoding_svm', sFiles_all, [], ...
    'sensortypes',      'EEG', ...
    'lowpass',          40, ...
    'num_permutations', 100, ...
    'kfold',            5, ...
    'method',           1);     % Pairwise

% 结果：准确率>50%表示可解码
```

---

### 1.2 Max-Correlation解码 (process_decoding_maxcorr.m)

**最大相关分类器**

**原理：**
```matlab
% 为每个条件创建模板
template_A = mean(trials_A, 1);  % 对试次求平均
template_B = mean(trials_B, 1);

% 测试试次分类
for trial in test_trials:
    corr_A = corr(trial, template_A);
    corr_B = corr(trial, template_B);
    
    % 分配到最相关的类别
    if corr_A > corr_B:
        label = 'A';
    else:
        label = 'B';
    end
end
```

**优点：**
- ✓ 简单快速
- ✓ 无需优化参数
- ✓ 适合ERP数据

**使用：**
```matlab
sFiles = bst_process('CallProcess', 'process_decoding_maxcorr', sFiles, [], ...
    'sensortypes',       'MEG', ...
    'num_permutations',  50, ...
    'kfold',             5);
```

---

### 1.3 LDA解码

**线性判别分析（Linear Discriminant Analysis）**

**原理：**
```matlab
% 找到投影方向w，最大化类间方差/类内方差
% Fisher判别准则
J(w) = (w'*S_B*w) / (w'*S_W*w)

% S_B: 类间散度矩阵
S_B = (μ_1 - μ_2)*(μ_1 - μ_2)'

% S_W: 类内散度矩阵
S_W = Σ_1 + Σ_2
```

**vs SVM：**
- LDA: 假设高斯分布，计算更快
- SVM: 非参数，更灵活

---

## 2. 交叉验证

### 2.1 K-Fold交叉验证

**流程：**
```matlab
% 将数据分为K份
K = 5;
indices = crossvalind('Kfold', nTrials, K);

for k = 1:K
    % 测试集
    test_idx = (indices == k);
    test_data = trials(test_idx);
    
    % 训练集
    train_idx = ~test_idx;
    train_data = trials(train_idx);
    
    % 训练模型
    model = train_classifier(train_data, labels(train_idx));
    
    % 测试
    pred = predict(model, test_data);
    accuracy(k) = mean(pred == labels(test_idx));
end

% 平均准确率
mean_accuracy = mean(accuracy);
```

---

### 2.2 Leave-One-Out (LOO)

**每次留一个试次：**
```matlab
% K = nTrials
for i = 1:nTrials
    train_data = trials([1:i-1, i+1:end]);
    test_data = trials(i);
    
    model = train(train_data);
    pred(i) = predict(model, test_data);
end

accuracy = mean(pred == labels);
```

**优点：** 最大化训练数据
**缺点：** 计算开销大

---

### 2.3 Stratified K-Fold

**保持类别比例：**
```matlab
% 确保每个fold有相同的类别分布
cv = cvpartition(labels, 'KFold', 5);

for k = 1:5
    train_idx = cv.training(k);
    test_idx = cv.test(k);
    % ...
end
```

---

## 3. 置换检验

### 3.1 解码显著性

**原理：** 打乱标签生成零分布

```matlab
% 观测准确率
acc_obs = decode(data, labels);

% 置换
for perm = 1:nPerm
    % 随机打乱标签
    labels_perm = labels(randperm(length(labels)));
    
    % 解码
    acc_perm(perm) = decode(data, labels_perm);
end

% p值
p = (sum(acc_perm >= acc_obs) + 1) / (nPerm + 1);
```

**解释：**
- p < 0.05: 解码显著高于偶然水平
- 偶然水平（二分类）= 50%

---

### 3.2 聚类校正

**时间聚类：**
```matlab
% 计算每个时间点的准确率
for t = 1:nTime
    acc(t) = decode_at_time(data(:, t, :), labels);
end

% 阈值化（如：>55%）
acc_thresh = acc .* (acc > 0.55);

% 识别时间聚类
clusters = find_clusters_1d(acc_thresh);

% 置换检验（与统计分析类似）
% ...
```

---

## 4. 特征提取

### 4.1 时间域特征

**峰值振幅：**
```matlab
% 提取N170峰值
sFiles = bst_process('CallProcess', 'process_extract_time', sFiles, [], ...
    'timewindow',  [0.15, 0.19], ...
    'scouts',      {}, ...
    'scoutfunc',   1, ...      % Mean
    'isabs',       0);
```

---

### 4.2 频域特征

**功率谱密度（PSD）：**
```matlab
% 提取α波段功率
sFiles_tf = bst_process('CallProcess', 'process_timefreq', sFiles, []);

sFiles_alpha = bst_process('CallProcess', 'process_extract_scout', sFiles_tf, [], ...
    'timewindow',  [0, 2], ...
    'scouts',      {'Desikan-Killiany', 'posteriorcingulate L'}, ...
    'scoutfunc',   1, ...
    'freqrange',   [8, 13]);   % α频段
```

---

### 4.3 连接性特征

**功能连接：**
```matlab
% 提取coherence矩阵作为特征
sFiles_coh = bst_process('CallProcess', 'process_cohere1n', sFiles, [], ...
    'timewindow',  [0, 1], ...
    'scouts',      {'Desikan-Killiany', {'all'}}, ...
    'freqrange',   [8, 13]);

% 展平上三角作为特征向量
% nFeatures = nROIs * (nROIs - 1) / 2
```

---

### 4.4 空间模式

**Common Spatial Patterns (CSP)：**

**目标：** 找到最大化类间方差的空间滤波器

```matlab
% 协方差矩阵
C_A = cov(data_A');  % [nChannels × nChannels]
C_B = cov(data_B');

% 广义特征值分解
[W, D] = eig(C_A, C_A + C_B);

% 选择前m个和后m个特征向量
W_csp = [W(:, 1:m), W(:, end-m+1:end)];

% 投影数据
data_csp = W_csp' * data;  % [2m × nSamples]

% 特征：对数方差
features = log(var(data_csp, 0, 2));
```

**应用：** 运动想象BCI

---

## 5. Spike Sorting

### 5.1 WaveClus (process_spikesorting_waveclus.m)

**无监督spike分类**

**流程：**
```matlab
% 1. Spike检测
threshold = -5 * median(abs(LFP) / 0.6745);  % 鲁棒std
spike_times = find(LFP < threshold);

% 2. 对齐
% 提取spike波形（如：-1ms到+2ms）
for i = 1:length(spike_times)
    waveforms(i, :) = LFP(spike_times(i)-pre : spike_times(i)+post);
end

% 3. 特征提取：小波变换
coeffs = wavelet_decompose(waveforms);

% PCA降维
[coeff, score] = pca(coeffs);
features = score(:, 1:3);  % 前3个主成分

% 4. 聚类：超参数化聚类
clusters = superparamagnetic_clustering(features);

% 或使用GMM
GMM = fitgmdist(features, nClusters);
clusters = cluster(GMM, features);
```

**使用：**
```matlab
sFiles = bst_process('CallProcess', 'process_spikesorting_waveclus', sFiles, [], ...
    'binsize',      2, ...        % RAM限制（GB）
    'parallel',     0, ...
    'usessp',       1, ...
    'make_plots',   1);           % 保存聚类图

% 输出：每个神经元的spike事件
```

---

### 5.2 Kilosort (process_spikesorting_kilosort.m)

**基于模板匹配的spike sorting**

**原理：**
```matlab
% 1. 预处理：高通滤波（300 Hz）
% 2. Spike检测
% 3. 模板学习（期望最大化）
% 4. 模板匹配
% 5. 后处理：合并相似单元
```

**优点：**
- ✓ 处理大规模多通道数据
- ✓ 自动化程度高
- ✓ GPU加速

---

### 5.3 UltraMegaSort2000

**基于主成分的分类**

```matlab
% 特征：PCA
% 聚类：聚合层次聚类
```

---

## 6. 降维技术

### 6.1 主成分分析（PCA）

**应用：** 降低通道维度

```matlab
% 对MEG传感器空间降维
[coeff, score, latent] = pca(data');  % [nChannels × nTime]

% 保留99%方差
cumvar = cumsum(latent) / sum(latent);
nPC = find(cumvar >= 0.99, 1);

% 降维数据
data_reduced = score(:, 1:nPC)';
```

**解码中的应用：**
```matlab
% 先PCA降维再SVM
data_pca = pca_reduce(data, 0.95);  % 保留95%方差
accuracy = svm_decode(data_pca, labels);
```

---

### 6.2 独立成分分析（ICA）

**用于特征提取：**
```matlab
% 提取独立源
[icasig, A, W] = fastica(data);

% 选择任务相关成分
% （如：与刺激时间相关的成分）
for i = 1:size(icasig, 1)
    corr_with_task(i) = abs(corr(icasig(i, :)', task_regressor));
end

[~, task_IC] = max(corr_with_task);
features = icasig(task_IC, :);
```

---

### 6.3 t-SNE可视化

**高维数据可视化：**
```matlab
% 提取高维特征（如：所有通道×时间点）
features = reshape(data, [nTrials, nChannels*nTime]);

% t-SNE降至2D
Y = tsne(features, 'NumDimensions', 2);

% 可视化
gscatter(Y(:, 1), Y(:, 2), labels);
title('Trial similarity (t-SNE)');
```

**应用：** 检查类别可分性

---

## 7. 多变量模式分析（MVPA）

### 7.1 Representational Similarity Analysis (RSA)

**原理：** 比较神经表征的相似性结构

```matlab
% 1. 计算条件间的相异度矩阵（RDM）
nCond = length(unique(conditions));
RDM = zeros(nCond);

for i = 1:nCond
    for j = i+1:nCond
        % 欧氏距离
        data_i = mean(trials(conditions == i), 1);
        data_j = mean(trials(conditions == j), 1);
        RDM(i, j) = norm(data_i - data_j);
        RDM(j, i) = RDM(i, j);
    end
end

% 2. 与模型RDM比较
model_RDM = [...];  % 理论预测的相异度矩阵

% Spearman相关
rho = corr(RDM(:), model_RDM(:), 'type', 'Spearman');
```

**应用：**
- 类别编码（如：animate vs inanimate）
- 跨被试/跨模态表征一致性

---

### 7.2 Searchlight解码

**局部空间模式：**

```matlab
% 对每个源点及其邻域解码
for iSource = 1:nSources
    % 定义邻域（如：15mm半径）
    neighbors = find_neighbors(iSource, surface, 15);
    
    % 提取邻域数据
    data_local = source_data(neighbors, :, :);
    
    % 解码
    acc(iSource) = svm_decode(data_local, labels);
end

% 输出：源空间解码准确率图
```

**可视化：** 显示解码信息的脑区

---

## 8. 时间解码分析

### 8.1 解码动态

**解码准确率随时间变化：**

```matlab
% 滑动窗口解码
window_size = 50;  % ms
step = 10;         % ms

for t = 1:step:(nTime - window_size)
    data_window = data(:, t:t+window_size-1, :);
    acc(t) = decode(data_window, labels);
end

% 绘制
plot(time, acc);
xlabel('Time (s)');
ylabel('Decoding accuracy');
```

**解释：**
- 早期峰值：感觉编码
- 晚期峰值：决策/响应

---

### 8.2 解码峰值延迟

**提取信息出现时间：**

```matlab
% 找到超过阈值的第一个时间点
threshold = 0.55;  % 55%准确率
onset = find(acc > threshold, 1, 'first');

fprintf('信息出现时间: %.0f ms\n', time(onset) * 1000);
```

---

## 9. 实用场景

### 9.1 场景1：视觉分类解码

**任务：** 解码face vs house

```matlab
% 1. 选择文件
sFiles_face = bst_process('CallProcess', 'process_select_files_data', [], [], ...
    'condition', 'face');
sFiles_house = bst_process('CallProcess', 'process_select_files_data', [], [], ...
    'condition', 'house');

sFiles_all = [sFiles_face, sFiles_house];

% 2. 预处理
sFiles_filt = bst_process('CallProcess', 'process_bandpass', sFiles_all, [], ...
    'highpass', 1, ...
    'lowpass',  40);

% 3. SVM解码
sFiles_decode = bst_process('CallProcess', 'process_decoding_svm', sFiles_filt, [], ...
    'sensortypes',       'MEG MAG', ...
    'lowpass',           0, ...      % 已滤波
    'num_permutations',  100, ...
    'kfold',             5, ...
    'method',            1);         % Pairwise

% 4. 统计检验
% 检查准确率是否显著>50%
sFiles_stat = bst_process('CallProcess', 'process_test_parametric1', sFiles_decode, [], ...
    'timewindow',  [], ...
    'test_type',   'ttest_onesample', ...
    'tail',        'right');         % 单侧：>50%

% 5. 可视化
view_timeseries(sFiles_decode{1}, 'MEG');
```

---

### 9.2 场景2：运动想象BCI

**左手vs右手想象：**

```matlab
% 1. 提取运动皮层ROI
sFiles_src = bst_process('CallProcess', 'process_inverse', sFiles, []);

sFiles_scout = bst_process('CallProcess', 'process_extract_scout', sFiles_src, [], ...
    'scouts',     {'Desikan-Killiany', {'precentral L', 'precentral R'}}, ...
    'scoutfunc',  1);

% 2. 时频分解
sFiles_tf = bst_process('CallProcess', 'process_timefreq', sFiles_scout, [], ...
    'sensortypes', 'MEG', ...
    'method',      'morlet', ...
    'freqs',       [8:2:30]);

% 3. 提取β波段功率（运动想象标志）
sFiles_beta = bst_process('CallProcess', 'process_extract_time', sFiles_tf, [], ...
    'timewindow',  [0, 3], ...
    'freqrange',   [13, 30]);

% 4. 解码
sFiles_decode = bst_process('CallProcess', 'process_decoding_svm', sFiles_beta, [], ...
    'num_permutations', 50, ...
    'kfold',            10);  % LOO近似

% 5. 在线BCI：训练分类器
model = train_classifier(training_data, training_labels);

% 实时预测
prediction = predict(model, online_features);
```

---

### 9.3 场景3：P300 Speller

**检测稀有刺激：**

```matlab
% 1. 标记target vs non-target
% Target: 用户注视的字母/数字
% Non-target: 其他

% 2. 下采样non-target（平衡类别）
nTarget = length(sFiles_target);
sFiles_nontarget_sub = sFiles_nontarget(randperm(length(sFiles_nontarget), nTarget));

% 3. 解码
sFiles_all = [sFiles_target, sFiles_nontarget_sub];
sFiles_decode = bst_process('CallProcess', 'process_decoding_svm', sFiles_all, []);

% 4. 字符识别
% 对每个行/列刺激的解码输出投票
```

---

## 10. 高级技巧

### 10.1 特征选择

**去除冗余特征：**

```matlab
% 基于方差
var_features = var(features, 0, 1);
top_features = find(var_features > prctile(var_features, 50));

% 基于F-score
[idx, scores] = fscmrmr(features, labels);
selected = idx(1:100);  % 前100个特征

% 递归特征消除（RFE）
% 迭代删除最不重要的特征
```

---

### 10.2 类别不平衡

**处理方法：**

```matlab
% 1. 过采样少数类（SMOTE）
% 2. 欠采样多数类
% 3. 加权损失函数

% SVM加权
weights = [nTotal/nClass1, nTotal/nClass2];
model = fitcsvm(features, labels, 'Weights', weights);
```

---

### 10.3 集成学习

**Ensemble方法：**

```matlab
% Bagging
nModels = 10;
for i = 1:nModels
    % Bootstrap样本
    idx = randsample(nTrials, nTrials, true);
    models{i} = train(features(idx, :), labels(idx));
end

% 投票
for trial = 1:nTest
    votes = zeros(nModels, 1);
    for i = 1:nModels
        votes(i) = predict(models{i}, test_features(trial, :));
    end
    final_prediction(trial) = mode(votes);
end
```

---

## 11. 评估指标

### 11.1 准确率

```matlab
accuracy = mean(predictions == true_labels);
```

**局限：** 类别不平衡时误导

---

### 11.2 混淆矩阵

```matlab
C = confusionmat(true_labels, predictions);

% C(i,j) = 真实类别i被预测为j的次数
```

---

### 11.3 精确率、召回率、F1

```matlab
% 精确率（Precision）
precision = TP / (TP + FP);

% 召回率（Recall/Sensitivity）
recall = TP / (TP + FN);

% F1分数
F1 = 2 * (precision * recall) / (precision + recall);
```

---

### 11.4 ROC曲线与AUC

```matlab
% ROC: Receiver Operating Characteristic
[X, Y, T, AUC] = perfcurve(labels, scores, positive_class);

% AUC = 0.5: 随机
% AUC = 1.0: 完美
% AUC > 0.7: 可接受

plot(X, Y);
xlabel('False Positive Rate');
ylabel('True Positive Rate');
title(['AUC = ', num2str(AUC)]);
```

---

## 12. 常见陷阱

### 12.1 数据泄露

**错误：** 在交叉验证前做特征选择/归一化

```matlab
% ❌ 错误
features_selected = feature_selection(data);
cv_accuracy = cross_validate(features_selected);

% ✓ 正确
for fold = 1:K
    train_data = data(train_idx, :);
    test_data = data(test_idx, :);
    
    % 仅在训练集上选择特征
    selected = feature_selection(train_data);
    
    % 应用到测试集
    model = train(train_data(:, selected));
    acc(fold) = test(model, test_data(:, selected));
end
```

---

### 12.2 时间泄漏

**问题：** 使用未来信息

```matlab
% ❌ 在整个trial上滤波后分段
data_filt = bandpass(data_all);
trials = segment(data_filt);

% ✓ 先分段再滤波（或用因果滤波器）
trials = segment(data_all);
for i = 1:nTrials
    trials_filt{i} = causal_filter(trials{i});
end
```

---

### 12.3 重复测量

**问题：** 同一被试的多个trial不独立

**解决：** 被试级交叉验证

```matlab
% 按被试分fold，而非按trial
subjects = [1,1,1,2,2,2,3,3,3,...];  % trial的被试ID
cv = cvpartition(subjects, 'KFold', 5);
```

---

## 13. 软件依赖

### 13.1 LibSVM

**安装：**
```matlab
% Brainstorm自动安装
bst_plugin('Install', 'libsvm');
```

**编译（可选）：**
```bash
cd external/libsvm/matlab
make
```

---

### 13.2 Statistics Toolbox

**所需函数：**
- `fitcsvm`
- `crossval`
- `cvpartition`

---

## 14. 性能优化

### 14.1 降维

**减少计算：**
```matlab
% 时间降采样
data_downsamp = data(:, 1:10:end, :);  % 每10个点取1个

% 空间降维（PCA）
[coeff, score] = pca(data');
data_reduced = score(:, 1:50)';  % 保留50个PC
```

---

### 14.2 并行计算

```matlab
% 启用parfor
parpool(4);  % 4个worker

parfor fold = 1:nFolds
    accuracy(fold) = decode_fold(data, labels, fold);
end
```

---

## 15. 参考文献

1. King & Dehaene (2014). Characterizing the dynamics of mental representations: the temporal generalization method
2. Grootswagers et al. (2017). Decoding dynamic brain patterns from evoked responses
3. Oostenveld et al. (2011). FieldTrip: Open source software for advanced analysis of MEG, EEG, and invasive electrophysiological data
4. Quiroga et al. (2004). Unsupervised spike detection and sorting with wavelets and superparamagnetic clustering (WaveClus)
5. Kriegeskorte et al. (2008). Representational similarity analysis

---

## 附录：函数速查表

| 函数 | 功能 | 主要参数 |
|------|------|----------|
| `process_decoding_svm` | SVM解码 | 传感器类型, 滤波, 置换次数, K折 |
| `process_decoding_maxcorr` | 最大相关解码 | 同上 |
| `process_spikesorting_waveclus` | WaveClus spike sorting | RAM限制, 并行, SSP |
| `process_spikesorting_kilosort` | Kilosort分类 | GPU, 模板参数 |
| `process_extract_scout` | 提取ROI数据 | ROI名称, 函数（均值/PCA） |
| `process_extract_time` | 提取时间窗口 | 时间范围, 统计量 |
| `process_extract_values` | 提取值 | 坐标, 插值 |
