# NumPy 数值计算模块详解

## 1. 概述

NumPy 提供了多个专门用于数值计算的子模块，涵盖线性代数、傅里叶变换、随机数生成、多项式运算等领域。

## 2. 线性代数模块 (numpy.linalg)

### 2.1 模块概述

`numpy.linalg` 提供线性代数功能，依赖于 BLAS 和 LAPACK 库。

**底层库选项**:
- OpenBLAS (开源，高性能)
- Intel MKL (商业，针对 Intel CPU 优化)
- ATLAS (自动调优)
- 参考实现 (纯 C，性能较低)

### 2.2 主要功能分类

#### 2.2.1 矩阵和向量乘积

```python
# 在主命名空间中
np.dot(a, b)              # 点积/矩阵乘法
np.vdot(a, b)             # 向量点积（共轭）
np.inner(a, b)            # 内积
np.outer(a, b)            # 外积
np.matmul(a, b)           # 矩阵乘法（推荐）
np.tensordot(a, b)        # 张量积
np.einsum('ij,jk->ik', a, b)  # Einstein 求和
np.kron(a, b)             # Kronecker 积

# 在 linalg 中
np.linalg.multi_dot([a, b, c])    # 多个矩阵点积
np.linalg.matrix_power(a, n)      # 矩阵幂
```

**示例**:
```python
import numpy as np

A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])

# 矩阵乘法
C = A @ B  # 或 np.matmul(A, B)
# [[19 22]
#  [43 50]]

# 向量点积
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])
result = np.dot(a, b)  # 32
```

#### 2.2.2 矩阵分解

**Cholesky 分解**:
```python
np.linalg.cholesky(a)
# 对于正定矩阵 A，返回下三角矩阵 L 使得 A = L @ L.T
```

**QR 分解**:
```python
Q, R = np.linalg.qr(a, mode='reduced')
# A = Q @ R，Q 是正交矩阵，R 是上三角矩阵
```

**SVD（奇异值分解）**:
```python
U, s, Vh = np.linalg.svd(a, full_matrices=True)
# A = U @ diag(s) @ Vh
# U: 左奇异向量
# s: 奇异值
# Vh: 右奇异向量的共轭转置

# 仅获取奇异值
s = np.linalg.svdvals(a)
```

**LU 分解**（通过 SciPy）:
```python
# NumPy 没有直接的 LU 分解，使用 scipy.linalg.lu
```

#### 2.2.3 矩阵特征值

**特征值和特征向量**:
```python
# 一般矩阵
eigenvalues, eigenvectors = np.linalg.eig(a)

# 实对称或复 Hermite 矩阵（更快更准确）
eigenvalues, eigenvectors = np.linalg.eigh(a)

# 仅计算特征值
eigenvalues = np.linalg.eigvals(a)
eigenvalues = np.linalg.eigvalsh(a)  # 对称/Hermite 矩阵
```

**示例**:
```python
A = np.array([[1, 2], [2, 1]])
eigenvalues, eigenvectors = np.linalg.eigh(A)
print(eigenvalues)     # [-1.  3.]
print(eigenvectors)
# [[-0.70710678  0.70710678]
#  [ 0.70710678  0.70710678]]
```

#### 2.2.4 范数和其他数值

**向量范数**:
```python
np.linalg.norm(x, ord=None)
# ord=None: Frobenius 范数
# ord=1: L1 范数（绝对值之和）
# ord=2: L2 范数（欧几里得范数）
# ord=np.inf: 无穷范数（最大绝对值）

# NumPy 2.0+
np.linalg.vector_norm(x, ord=2)
```

**矩阵范数**:
```python
np.linalg.norm(A, ord='fro')  # Frobenius 范数
np.linalg.norm(A, ord=1)      # 1-范数
np.linalg.norm(A, ord=2)      # 2-范数（谱范数）
np.linalg.norm(A, ord=np.inf) # 无穷范数

# NumPy 2.0+
np.linalg.matrix_norm(A, ord='fro')
```

**条件数**:
```python
np.linalg.cond(A, p=None)
# 衡量矩阵的数值稳定性
# cond(A) = ||A|| * ||A^{-1}||
```

**行列式**:
```python
det = np.linalg.det(A)
```

**符号和对数行列式**:
```python
sign, logdet = np.linalg.slogdet(A)
# det = sign * exp(logdet)
# 用于避免数值溢出
```

**矩阵秩**:
```python
rank = np.linalg.matrix_rank(A, tol=None)
```

**迹**:
```python
trace = np.trace(A)  # 或
trace = np.linalg.trace(A)
```

#### 2.2.5 求解线性方程组

**一般线性系统**:
```python
# 求解 Ax = b
x = np.linalg.solve(A, b)
```

**最小二乘解**:
```python
# 求解 min ||Ax - b||^2
x, residuals, rank, s = np.linalg.lstsq(A, b, rcond=None)
```

**张量线性方程**:
```python
# 求解 a x b = c
x = np.linalg.tensorsolve(a, c)
```

#### 2.2.6 矩阵求逆

**逆矩阵**:
```python
A_inv = np.linalg.inv(A)
# 满足 A @ A_inv = I
```

**Moore-Penrose 伪逆**:
```python
A_pinv = np.linalg.pinv(A, rcond=1e-15)
# 适用于奇异矩阵或非方阵
```

**张量逆**:
```python
inv = np.linalg.tensorinv(a, ind=2)
```

#### 2.2.7 其他矩阵操作

**对角线**:
```python
diag = np.linalg.diagonal(A)
# 或主命名空间的
diag = np.diagonal(A)
```

**矩阵转置**:
```python
At = np.linalg.matrix_transpose(A)
# Array API 兼容版本
```

### 2.3 异常

```python
np.linalg.LinAlgError
# 线性代数操作失败时抛出
```

### 2.4 性能考虑

**多线程**:
```python
# BLAS/LAPACK 库通常是多线程的
# 使用 threadpoolctl 控制线程数
from threadpoolctl import threadpool_limits

with threadpool_limits(limits=4):
    result = np.linalg.svd(large_matrix)
```

**内存布局**:
```python
# Fortran 顺序对某些操作更快
A_f = np.asfortranarray(A)
result = np.linalg.solve(A_f, b)
```

## 3. 傅里叶变换模块 (numpy.fft)

### 3.1 模块概述

`numpy.fft` 提供离散傅里叶变换（DFT）功能，使用快速傅里叶变换（FFT）算法。

> **注意**: SciPy 的 `scipy.fft` 是更全面的超集，提供更多功能和更好的性能。

### 3.2 标准 FFT

#### 3.2.1 一维 FFT

```python
# 正向变换
fft_result = np.fft.fft(signal, n=None)
# n: 输出长度（可选）

# 逆变换
signal_reconstructed = np.fft.ifft(fft_result, n=None)
```

**示例**:
```python
import numpy as np

# 创建信号：5Hz 和 10Hz 的正弦波
t = np.linspace(0, 1, 500)
signal = np.sin(2 * np.pi * 5 * t) + 0.5 * np.sin(2 * np.pi * 10 * t)

# FFT
fft_result = np.fft.fft(signal)
frequencies = np.fft.fftfreq(len(signal), t[1] - t[0])

# 功率谱
power = np.abs(fft_result) ** 2
```

#### 3.2.2 二维 FFT

```python
# 正向变换
fft2_result = np.fft.fft2(image, s=None)
# s: 输出形状 (rows, cols)

# 逆变换
image_reconstructed = np.fft.ifft2(fft2_result, s=None)
```

#### 3.2.3 N 维 FFT

```python
# 正向变换
fftn_result = np.fft.fftn(data, s=None, axes=None)
# s: 输出形状
# axes: 进行变换的轴

# 逆变换
data_reconstructed = np.fft.ifftn(fftn_result, s=None, axes=None)
```

### 3.3 实数 FFT

对于实数输入，利用对称性提高效率：

```python
# 一维实数 FFT
rfft_result = np.fft.rfft(real_signal, n=None)
real_signal_reconstructed = np.fft.irfft(rfft_result, n=None)

# 二维实数 FFT
rfft2_result = np.fft.rfft2(real_image, s=None)
real_image_reconstructed = np.fft.irfft2(rfft2_result, s=None)

# N 维实数 FFT
rfftn_result = np.fft.rfftn(real_data, s=None, axes=None)
real_data_reconstructed = np.fft.irfftn(rfftn_result, s=None, axes=None)
```

**输出大小**:
```python
# 对于长度为 n 的实数输入
# rfft 输出长度为 n//2 + 1
input_signal = np.random.randn(100)
rfft_result = np.fft.rfft(input_signal)
print(len(rfft_result))  # 51
```

### 3.4 Hermite FFT

```python
# 假设输入在频域中是 Hermite 对称的
hfft_result = np.fft.hfft(hermite_signal, n=None)
hermite_signal = np.fft.ihfft(hfft_result, n=None)
```

### 3.5 辅助函数

#### 3.5.1 频率数组

```python
# FFT 频率
freqs = np.fft.fftfreq(n, d=1.0)
# n: 窗口长度
# d: 采样间隔

# 实数 FFT 频率
freqs = np.fft.rfftfreq(n, d=1.0)
# 只返回正频率
```

#### 3.5.2 频谱移位

```python
# 将零频率分量移到中心
shifted = np.fft.fftshift(fft_result, axes=None)

# 逆操作
original = np.fft.ifftshift(shifted, axes=None)
```

**示例**:
```python
# 绘制中心化的频谱
fft_result = np.fft.fft2(image)
fft_shifted = np.fft.fftshift(fft_result)
magnitude_spectrum = np.log(np.abs(fft_shifted) + 1)
```

### 3.6 DFT 定义

NumPy 使用的 DFT 定义：

$$A_k = \sum_{m=0}^{n-1} a_m \exp\left\{-2\pi i \frac{mk}{n}\right\} \quad k = 0, \ldots, n-1$$

逆变换：

$$a_m = \frac{1}{n} \sum_{k=0}^{n-1} A_k \exp\left\{2\pi i \frac{mk}{n}\right\} \quad m = 0, \ldots, n-1$$

### 3.7 性能提示

**优化长度**:
```python
# FFT 对 2 的幂次长度最快
# 使用零填充到最近的 2 的幂
n_optimal = 2 ** int(np.ceil(np.log2(len(signal))))
fft_result = np.fft.fft(signal, n=n_optimal)
```

**in-place 操作**:
```python
# NumPy FFT 不支持 in-place，考虑使用 scipy.fft
```

## 4. 随机数生成模块 (numpy.random)

### 4.1 新 API (推荐)

NumPy 1.17+ 引入新的随机数生成 API。

#### 4.1.1 Generator 和 BitGenerator

**创建生成器**:
```python
from numpy.random import default_rng

# 使用默认种子
rng = default_rng()

# 使用指定种子
rng = default_rng(12345)

# 使用 SeedSequence
from numpy.random import SeedSequence
ss = SeedSequence(12345)
rng = default_rng(ss)
```

**BitGenerator 选项**:
```python
from numpy.random import Generator, PCG64, MT19937, Philox, SFC64

# PCG64 (默认，推荐)
rng = Generator(PCG64(12345))

# PCG64DXSM (更好的统计性质)
from numpy.random import PCG64DXSM
rng = Generator(PCG64DXSM(12345))

# MT19937 (Mersenne Twister，兼容旧版)
rng = Generator(MT19937(12345))

# Philox (可并行化)
rng = Generator(Philox(12345))

# SFC64 (快速)
rng = Generator(SFC64(12345))
```

#### 4.1.2 均匀分布

```python
# 连续均匀分布 [0, 1)
samples = rng.random(size=None)

# 离散均匀分布 [low, high)
samples = rng.integers(low, high=None, size=None, endpoint=False)

# 字节
bytes_array = rng.bytes(length)
```

#### 4.1.3 正态分布

```python
# 标准正态分布 N(0, 1)
samples = rng.standard_normal(size=None)

# 正态分布 N(loc, scale^2)
samples = rng.normal(loc=0.0, scale=1.0, size=None)
```

#### 4.1.4 其他连续分布

```python
# Beta 分布
rng.beta(a, b, size=None)

# 指数分布
rng.exponential(scale=1.0, size=None)

# Gamma 分布
rng.gamma(shape, scale=1.0, size=None)

# 卡方分布
rng.chisquare(df, size=None)

# F 分布
rng.f(dfnum, dfden, size=None)

# 对数正态分布
rng.lognormal(mean=0.0, sigma=1.0, size=None)

# Laplace 分布
rng.laplace(loc=0.0, scale=1.0, size=None)

# Logistic 分布
rng.logistic(loc=0.0, scale=1.0, size=None)

# Pareto 分布
rng.pareto(a, size=None)

# Rayleigh 分布
rng.rayleigh(scale=1.0, size=None)

# 三角分布
rng.triangular(left, mode, right, size=None)

# Weibull 分布
rng.weibull(a, size=None)

# Gumbel 分布
rng.gumbel(loc=0.0, scale=1.0, size=None)

# Von Mises 分布
rng.vonmises(mu, kappa, size=None)

# Wald 分布
rng.wald(mean, scale, size=None)
```

#### 4.1.5 离散分布

```python
# 二项分布
rng.binomial(n, p, size=None)

# 几何分布
rng.geometric(p, size=None)

# 超几何分布
rng.hypergeometric(ngood, nbad, nsample, size=None)

# 负二项分布
rng.negative_binomial(n, p, size=None)

# 泊松分布
rng.poisson(lam=1.0, size=None)

# Zipf 分布
rng.zipf(a, size=None)

# 对数级数分布
rng.logseries(p, size=None)
```

#### 4.1.6 多元分布

```python
# 多元正态分布
mean = [0, 0]
cov = [[1, 0.5], [0.5, 1]]
samples = rng.multivariate_normal(mean, cov, size=None)

# 多项分布
rng.multinomial(n, pvals, size=None)

# Dirichlet 分布
rng.dirichlet(alpha, size=None)
```

#### 4.1.7 排列和选择

```python
# 随机排列
rng.permutation(x)  # x 可以是整数或数组

# 原地打乱
rng.shuffle(x)  # 修改 x

# 随机选择
rng.choice(a, size=None, replace=True, p=None)
```

### 4.2 旧 API (遗留)

**全局状态**:
```python
# 设置种子
np.random.seed(12345)

# 使用函数
samples = np.random.random(100)
samples = np.random.randn(100)
samples = np.random.randint(0, 10, size=100)
```

**遗留函数**:
```python
np.random.rand()        # 均匀分布
np.random.randn()       # 标准正态
np.random.randint()     # 随机整数
np.random.choice()      # 随机选择
np.random.shuffle()     # 打乱
np.random.permutation() # 排列
```

### 4.3 并行随机数生成

```python
from numpy.random import SeedSequence, default_rng

# 创建独立的流
ss = SeedSequence(12345)
child_seeds = ss.spawn(10)  # 生成 10 个子种子

# 在多个进程/线程中使用
rng_list = [default_rng(s) for s in child_seeds]
```

## 5. 多项式模块 (numpy.polynomial)

### 5.1 新多项式 API

NumPy 提供多种多项式基：

```python
from numpy.polynomial import (
    Polynomial,      # 标准幂基
    Chebyshev,      # Chebyshev 多项式
    Legendre,       # Legendre 多项式
    Laguerre,       # Laguerre 多项式
    Hermite,        # Hermite 多项式（概率论家）
    HermiteE,       # Hermite 多项式（物理学家）
)
```

**示例**:
```python
# 创建多项式: 1 + 2x + 3x^2
p = Polynomial([1, 2, 3])

# 计算值
y = p(2.0)  # 1 + 2*2 + 3*2^2 = 17

# 加法
p1 = Polynomial([1, 2])
p2 = Polynomial([3, 4])
p3 = p1 + p2  # [4, 6]

# 乘法
p4 = p1 * p2

# 微分
p_deriv = p.deriv()

# 积分
p_integ = p.integ()

# 根
roots = p.roots()

# 拟合
x = np.linspace(0, 10, 100)
y = 2 + 3*x + 5*x**2 + noise
p_fit = Polynomial.fit(x, y, deg=2)
```

### 5.2 旧多项式 API (numpy.poly1d)

```python
# 从系数创建
p = np.poly1d([3, 2, 1])  # 3x^2 + 2x + 1

# 从根创建
p = np.poly1d([1, 2, 3], r=True)  # (x-1)(x-2)(x-3)

# 操作
p_deriv = np.polyder(p)
p_integ = np.polyint(p)
roots = np.roots(p)
poly_from_roots = np.poly(roots)
```

## 6. 总结

NumPy 的数值计算模块提供了：

1. **numpy.linalg**: 全面的线性代数功能
   - 矩阵分解、特征值、求解线性系统

2. **numpy.fft**: 快速傅里叶变换
   - 标准 FFT、实数 FFT、Hermite FFT

3. **numpy.random**: 现代化的随机数生成
   - Generator API、多种分布、并行支持

4. **numpy.polynomial**: 多项式运算
   - 多种多项式基、拟合、求值

这些模块是科学计算的基础工具。

---

**相关文档**:
- [02_核心模块详解.md](02_核心模块详解.md)
- [04_数据类型系统.md](04_数据类型系统.md)
- [06_辅助模块详解.md](06_辅助模块详解.md)
