# NumPy 辅助模块详解

## 1. lib 模块 (numpy.lib)

`numpy.lib` 包含不适合放在主命名空间的实用工具和功能。

### 1.1 模块结构

```
numpy.lib/
├── _function_base_impl.py    # 基础函数实现
├── _nanfunctions_impl.py      # NaN 处理函数
├── _histograms_impl.py        # 直方图
├── _shape_base_impl.py        # 形状操作
├── _twodim_base_impl.py       # 二维操作
├── _type_check_impl.py        # 类型检查
├── _arraysetops_impl.py       # 数组集合操作
├── _arraypad_impl.py          # 数组填充
├── _index_tricks_impl.py      # 索引技巧
├── _polynomial_impl.py        # 多项式（旧API）
├── _npyio_impl.py             # I/O 操作
├── _stride_tricks_impl.py     # 步长技巧
├── _ufunclike_impl.py         # 类ufunc函数
└── _utils_impl.py             # 通用工具
```

### 1.2 主要功能分类

#### 1.2.1 NaN 处理函数

处理包含 NaN 的数组：

```python
arr = np.array([1, 2, np.nan, 4, np.nan, 6])

# 忽略 NaN 的统计函数
np.nansum(arr)       # 13.0
np.nanmean(arr)      # 3.25
np.nanstd(arr)       # 标准差
np.nanvar(arr)       # 方差
np.nanmin(arr)       # 1.0
np.nanmax(arr)       # 6.0
np.nanmedian(arr)    # 中位数
np.nanpercentile(arr, 50)  # 百分位数
np.nanquantile(arr, 0.5)   # 分位数

# 累积函数
np.nancumsum(arr)    # 忽略 NaN 的累加
np.nancumprod(arr)   # 忽略 NaN 的累乘

# 参数函数
np.nanargmin(arr)    # 最小值索引
np.nanargmax(arr)    # 最大值索引
```

**多维数组**:
```python
arr = np.array([[1, 2, np.nan],
                [4, np.nan, 6],
                [7, 8, 9]])

# 沿轴操作
np.nanmean(arr, axis=0)  # 列均值
np.nanmean(arr, axis=1)  # 行均值
```

#### 1.2.2 直方图

```python
# 一维直方图
data = np.random.randn(1000)
hist, bin_edges = np.histogram(data, bins=10)

# 指定范围
hist, bin_edges = np.histogram(data, bins=10, range=(-3, 3))

# 归一化
hist, bin_edges = np.histogram(data, bins=10, density=True)

# 仅获取边界
bin_edges = np.histogram_bin_edges(data, bins='auto')

# 二维直方图
x = np.random.randn(1000)
y = np.random.randn(1000)
hist, xedges, yedges = np.histogram2d(x, y, bins=10)

# 多维直方图
sample = np.random.randn(1000, 3)
hist, edges = np.histogramdd(sample, bins=10)
```

**分箱策略**:
```python
# 自动选择箱数
bins = 'auto'      # 自动（Sturges' 公式）
bins = 'fd'        # Freedman-Diaconis
bins = 'doane'     # Doane's 公式
bins = 'scott'     # Scott's 规则
bins = 'stone'     # Stone's 公式
bins = 'rice'      # Rice 规则
bins = 'sqrt'      # 平方根选择

hist, edges = np.histogram(data, bins='auto')
```

#### 1.2.3 形状操作

```python
# 应用函数到轴
arr = np.array([[1, 2, 3],
                [4, 5, 6]])

def my_func(row):
    return row.mean()

result = np.apply_along_axis(my_func, axis=1, arr=arr)
# [2. 5.]

# 应用函数到多个轴
result = np.apply_over_axes(np.sum, arr, axes=[0, 1])

# 分割数组
arrays = np.array_split(arr, 3, axis=1)
# 或
arrays = np.split(arr, [1, 2], axis=1)  # 在索引1和2处分割

# 水平/垂直/深度分割
hsplit = np.hsplit(arr, 3)      # 水平分割
vsplit = np.vsplit(arr, 2)      # 垂直分割
dsplit = np.dsplit(arr_3d, 2)   # 深度分割

# 堆叠
row_stack = np.row_stack([arr1, arr2])  # 垂直堆叠
column_stack = np.column_stack([arr1, arr2])  # 水平堆叠

# 扩展维度
expanded = np.expand_dims(arr, axis=0)

# Kronecker 乘积
kron = np.kron(arr1, arr2)

# tile 和 repeat
tiled = np.tile(arr, (2, 3))    # 平铺
repeated = np.repeat(arr, 2, axis=0)  # 重复

# 沿轴放置/提取值
indices = np.array([[0, 1], [1, 2]])
values = np.take_along_axis(arr, indices, axis=1)
np.put_along_axis(arr, indices, values, axis=1)
```

#### 1.2.4 二维操作

```python
# 对角线操作
diag = np.diag([1, 2, 3])       # 创建对角矩阵
diag_flat = np.diagflat([1, 2]) # 展平创建对角矩阵

# 单位矩阵
eye = np.eye(3, 4, k=1)         # 偏移对角线

# 三角矩阵
tri = np.tri(3, 5, k=1)         # 下三角
upper = np.triu(arr, k=1)       # 上三角
lower = np.tril(arr, k=-1)      # 下三角

# Vandermonde 矩阵
vander = np.vander([1, 2, 3, 4], N=3)
# [[1 1 1]
#  [4 2 1]
#  [9 3 1]
#  [16 4 1]]

# 翻转
fliplr = np.fliplr(arr)         # 左右翻转
flipud = np.flipud(arr)         # 上下翻转

# 对角线索引
diag_indices = np.diag_indices(3)
diag_indices_from = np.diag_indices_from(arr)

# 三角索引
tril_i = np.tril_indices(3)
tril_i_from = np.tril_indices_from(arr)
triu_i = np.triu_indices(3)
triu_i_from = np.triu_indices_from(arr)

# 掩码索引
mask_i = np.mask_indices(3, np.triu, k=1)
```

#### 1.2.5 类型检查

```python
# 复数检查
np.iscomplex([1, 2+3j])         # [False, True]
np.iscomplexobj(arr)            # 是否包含复数元素
np.isreal([1, 2+3j])            # [True, False]
np.isrealobj(arr)               # 是否只包含实数

# 提取实部/虚部
real = np.real([1+2j, 3+4j])    # [1., 3.]
imag = np.imag([1+2j, 3+4j])    # [2., 4.]

# NaN 转换
arr = np.array([1, np.nan, np.inf, -np.inf])
cleaned = np.nan_to_num(arr, nan=0.0, posinf=1e10, neginf=-1e10)

# 复数转实数（如果可能）
real_if_close = np.real_if_close([1+1e-10j, 2+1e-15j], tol=1000)

# 类型名称
typename = np.typename('f')     # 'float32'

# 最小类型码
mintypecode = np.mintypecode(['i', 'f'])  # 'f'

# 通用类型
common = np.common_type(arr1, arr2)
```

#### 1.2.6 集合操作

```python
a = np.array([1, 2, 3, 4, 5])
b = np.array([3, 4, 5, 6, 7])

# 唯一值
unique = np.unique(a)
unique, indices = np.unique(a, return_index=True)
unique, inverse = np.unique(a, return_inverse=True)
unique, counts = np.unique(a, return_counts=True)

# NumPy 2.0+ 分离的唯一函数
values = np.unique_values(a)
values, indices = np.unique_indices(a)
values, inverse = np.unique_inverse(a)
values, counts = np.unique_counts(a)
values, indices, inverse, counts = np.unique_all(a)

# 交集
intersect = np.intersect1d(a, b)        # [3, 4, 5]

# 并集
union = np.union1d(a, b)                # [1, 2, 3, 4, 5, 6, 7]

# 差集
setdiff = np.setdiff1d(a, b)            # [1, 2]

# 对称差
setxor = np.setxor1d(a, b)              # [1, 2, 6, 7]

# 成员测试
isin = np.isin(a, b)                    # [False, False, True, True, True]
in1d = np.in1d(a, b)                    # 等价于 isin

# 一维差分
ediff = np.ediff1d(a)                   # [1, 1, 1, 1]
```

#### 1.2.7 数组填充

```python
arr = np.array([1, 2, 3])

# 各种填充模式
padded = np.pad(arr, pad_width=2, mode='constant', constant_values=0)
# [0, 0, 1, 2, 3, 0, 0]

# 边缘填充
padded = np.pad(arr, 2, mode='edge')
# [1, 1, 1, 2, 3, 3, 3]

# 线性斜坡
padded = np.pad(arr, 2, mode='linear_ramp', end_values=0)

# 反射填充
padded = np.pad(arr, 2, mode='reflect')
# [3, 2, 1, 2, 3, 2, 1]

# 对称填充
padded = np.pad(arr, 2, mode='symmetric')
# [2, 1, 1, 2, 3, 3, 2]

# 包裹填充
padded = np.pad(arr, 2, mode='wrap')
# [2, 3, 1, 2, 3, 1, 2]

# 自定义函数
def pad_func(vector, iaxis_pad_width, iaxis, kwargs):
    return np.mean(vector)

padded = np.pad(arr, 2, mode=pad_func)

# 多维填充
arr_2d = np.array([[1, 2], [3, 4]])
padded = np.pad(arr_2d, ((1, 1), (2, 2)), mode='constant')
```

#### 1.2.8 索引技巧

```python
# 网格生成
x = np.arange(5)
y = np.arange(3)
xx, yy = np.meshgrid(x, y)

# ogrid（开放网格）
x, y = np.ogrid[0:5, 0:3]

# mgrid（密集网格）
x, y = np.mgrid[0:5, 0:3]

# r_ 和 c_（行和列拼接）
arr = np.r_[1:4, 0, 4]           # [1, 2, 3, 0, 4]
arr = np.c_[1:4, 4:7]            # [[1, 4], [2, 5], [3, 6]]

# s_（切片对象）
slice_obj = np.s_[2:5, ::2]
arr[slice_obj]

# index_exp（索引表达式）
idx = np.index_exp[2:5, ::2]

# ix_（开放网格索引）
ixgrid = np.ix_([0, 2], [1, 3])
arr[ixgrid]

# 多维索引迭代
for idx in np.ndindex(3, 2):
    print(idx)  # (0,0), (0,1), (1,0), ...

# 枚举多维索引
for idx, val in np.ndenumerate(arr):
    print(idx, val)

# unravel_index（展开索引）
idx = np.unravel_index([0, 1, 2, 3], (2, 2))
# (array([0, 0, 1, 1]), array([0, 1, 0, 1]))

# ravel_multi_index（合并索引）
idx = np.ravel_multi_index(([0, 0, 1, 1], [0, 1, 0, 1]), (2, 2))
# [0, 1, 2, 3]

# 填充对角线
arr = np.zeros((3, 3))
np.fill_diagonal(arr, 5)
# [[5, 0, 0],
#  [0, 5, 0],
#  [0, 0, 5]]
```

#### 1.2.9 I/O 操作

```python
# 保存文本
arr = np.array([[1, 2, 3], [4, 5, 6]])
np.savetxt('data.txt', arr, fmt='%d', delimiter=',')

# 加载文本
loaded = np.loadtxt('data.txt', delimiter=',')

# genfromtxt（更强大）
data = np.genfromtxt('data.csv', 
                     delimiter=',', 
                     skip_header=1,
                     missing_values='NA',
                     filling_values=0)

# 保存二进制
np.save('data.npy', arr)        # 单个数组
np.savez('data.npz', a=arr1, b=arr2)  # 多个数组
np.savez_compressed('data.npz', a=arr1)  # 压缩

# 加载二进制
loaded = np.load('data.npy')
archive = np.load('data.npz')
arr1 = archive['a']
arr2 = archive['b']

# 从正则表达式加载
data = np.fromregex('data.txt', r'(\d+)\s+(\d+)', dtype=[('x', int), ('y', int)])

# 打包/解包位
packed = np.packbits(np.array([1, 0, 1, 1, 0, 0, 1, 0], dtype=np.uint8))
unpacked = np.unpackbits(packed)
```

#### 1.2.10 步长技巧

```python
from numpy.lib.stride_tricks import as_strided

# 创建滑动窗口视图（不复制数据）
arr = np.arange(10)
# 创建大小为3的滑动窗口
windowed = as_strided(arr, 
                      shape=(8, 3),
                      strides=(arr.itemsize, arr.itemsize))
# [[0 1 2]
#  [1 2 3]
#  [2 3 4]
#  ...]

# 广播数组
from numpy.lib.stride_tricks import broadcast_arrays
a = np.array([1, 2, 3])
b = np.array([[1], [2], [3]])
a_bc, b_bc = broadcast_arrays(a, b)

# 广播到指定形状
from numpy.lib.stride_tricks import broadcast_to
broadcasted = broadcast_to(a, (3, 3))

# 广播形状
from numpy.lib.stride_tricks import broadcast_shapes
shape = broadcast_shapes((3, 1), (1, 4))  # (3, 4)
```

#### 1.2.11 函数基础

```python
# 分段函数
x = np.arange(10)
conditions = [x < 3, (x >= 3) & (x < 7), x >= 7]
choices = [x, x**2, x**3]
result = np.select(conditions, choices)

# 分段线性
result = np.piecewise(x, conditions, [lambda x: x, lambda x: x**2, lambda x: x**3])

# 去除前后零
arr = np.array([0, 0, 1, 2, 3, 0, 0])
trimmed = np.trim_zeros(arr)  # [1, 2, 3]

# 百分位数
data = np.array([1, 2, 3, 4, 5])
p25 = np.percentile(data, 25)   # 2.0
q25 = np.quantile(data, 0.25)   # 2.0

# 差分
diff = np.diff(data)            # [1, 1, 1, 1]
diff2 = np.diff(data, n=2)      # 二阶差分

# 梯度
gradient = np.gradient(data)

# 角度（相位）
complex_arr = np.array([1+1j, 1-1j])
angles = np.angle(complex_arr)  # [π/4, -π/4]

# 展开相位
phases = np.array([0, 0.78, 1.57, 2.35, 3.14])
unwrapped = np.unwrap(phases)

# 复数排序
complex_arr = np.array([1+2j, 2+1j, 1+1j])
sorted_complex = np.sort_complex(complex_arr)

# 翻转
flipped = np.flip(arr, axis=0)

# 旋转90度
rotated = np.rot90(arr_2d, k=1)  # k=旋转次数

# 提取
condition = arr > 5
extracted = np.extract(condition, arr)

# 放置
np.place(arr, condition, 99)

# 向量化
def my_func(x, y):
    return x + y
    
vfunc = np.vectorize(my_func)
result = vfunc([1, 2, 3], [4, 5, 6])

# 检查有限
arr_checked = np.asarray_chkfinite(arr)  # 如果有 inf/nan 则抛出异常

# 平均
avg = np.average(arr, weights=weights)

# bincount
arr = np.array([0, 1, 1, 2, 2, 2])
counts = np.bincount(arr)       # [1, 2, 3]

# digitize（数字化）
bins = [0, 1, 2, 3]
arr = np.array([0.5, 1.5, 2.5])
indices = np.digitize(arr, bins)  # [1, 2, 3]

# 协方差
cov_matrix = np.cov(data)

# 相关系数
corr_matrix = np.corrcoef(data)

# 中位数
median = np.median(data)

# sinc 函数
sinc_vals = np.sinc(x)

# 窗函数
hamming_window = np.hamming(10)
hanning_window = np.hanning(10)
bartlett_window = np.bartlett(10)
blackman_window = np.blackman(10)
kaiser_window = np.kaiser(10, beta=5)

# 梯形积分
integral = np.trapezoid(y, x)  # NumPy 2.0+
# 或
integral = np.trapz(y, x)      # 旧名称

# 贝塞尔函数
i0_vals = np.i0(x)

# 插值
interp_vals = np.interp(x_new, x_known, y_known)

# 删除/插入/追加
deleted = np.delete(arr, [1, 3], axis=0)
inserted = np.insert(arr, 2, values=99, axis=0)
appended = np.append(arr, values=[7, 8, 9], axis=0)
```

### 1.3 scimath 模块

`numpy.lib.scimath` 提供自动域的数学函数：

```python
from numpy.lib import scimath as sm

# 负数的平方根返回复数
result = sm.sqrt(-1)    # 1j
result = np.sqrt(-1)    # 警告并返回 nan

# 其他函数
sm.log(-1)      # 复数对数
sm.log2(-1)
sm.log10(-1)
sm.logn(n, -1)
sm.power(2, 1+1j)
```

## 2. testing 模块 (numpy.testing)

用于测试 NumPy 代码的工具。

### 2.1 断言函数

```python
from numpy.testing import (
    assert_array_equal,
    assert_array_almost_equal,
    assert_allclose,
    assert_equal,
    assert_,
)

# 数组相等
assert_array_equal(actual, desired)

# 数组近似相等
assert_array_almost_equal(actual, desired, decimal=7)

# 数组接近（相对和绝对容差）
assert_allclose(actual, desired, rtol=1e-7, atol=0)

# 通用相等
assert_equal(actual, desired)

# 布尔断言
assert_(condition, msg)

# 异常断言
from numpy.testing import assert_raises, assert_raises_regex
assert_raises(ValueError, func, *args)
assert_raises_regex(ValueError, 'pattern', func, *args)

# 警告断言
from numpy.testing import assert_warns
assert_warns(DeprecationWarning, func)

# 无警告
from numpy.testing import assert_no_warnings
assert_no_warnings(func)
```

### 2.2 装饰器

```python
from numpy.testing import (
    dec,
    suppress_warnings,
)

# 抑制警告
with suppress_warnings() as sup:
    sup.filter(DeprecationWarning)
    # 运行代码
```

### 2.3 运行测试

```python
# 运行 NumPy 测试
np.test()

# 运行特定模块的测试
np.linalg.test()

# 详细输出
np.test(verbose=2)
```

## 3. typing 模块 (numpy.typing)

NumPy 的类型标注支持。

### 3.1 NDArray 类型

```python
from numpy.typing import NDArray
import numpy as np

# 通用数组类型
def func(arr: NDArray) -> NDArray:
    return arr + 1

# 指定 dtype
def func(arr: NDArray[np.float64]) -> NDArray[np.float64]:
    return arr * 2

# 多种 dtype
from typing import Union
def func(arr: NDArray[Union[np.int32, np.int64]]) -> NDArray[np.float64]:
    return arr.astype(np.float64)
```

### 3.2 DTypeLike

```python
from numpy.typing import DTypeLike

def create_array(dtype: DTypeLike) -> NDArray:
    return np.zeros(10, dtype=dtype)
```

### 3.3 ArrayLike

```python
from numpy.typing import ArrayLike

def process(data: ArrayLike) -> NDArray:
    return np.asarray(data)
```

## 4. version 模块

```python
import numpy as np

# 版本字符串
print(np.version.version)      # '2.2.0'

# 完整版本信息
print(np.version.full_version) # '2.2.0+git...'

# 版本元组
print(np.version.short_version) # '2.2'

# Git 修订
print(np.version.git_revision)

# 发布状态
print(np.version.release)      # True/False
```

## 5. 总结

NumPy 的辅助模块提供了：

1. **numpy.lib**: 各种实用工具函数
   - NaN 处理、直方图、形状操作、I/O 等

2. **numpy.testing**: 测试工具
   - 断言函数、装饰器、测试运行器

3. **numpy.typing**: 类型标注支持
   - NDArray, ArrayLike, DTypeLike 等

4. **numpy.version**: 版本信息

这些模块增强了 NumPy 的功能和可用性。

---

**相关文档**:
- [02_核心模块详解.md](02_核心模块详解.md)
- [03_数值计算模块.md](03_数值计算模块.md)
- [08_最佳实践与常见模式.md](08_最佳实践与常见模式.md)
