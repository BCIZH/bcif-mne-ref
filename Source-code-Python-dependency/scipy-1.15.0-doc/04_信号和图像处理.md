# SciPy 信号和图像处理详解

## 1. scipy.signal - 信号处理

### 1.1 简介

`scipy.signal` 是信号处理工具箱，提供：
- 滤波器设计
- 信号滤波
- 频谱分析
- 卷积
- 窗函数
- 峰值检测
- 系统分析（LTI 系统）

### 1.2 模块结构

```
scipy.signal/
├── 滤波器设计
│   ├── butter()         # Butterworth
│   ├── cheby1()         # Chebyshev I
│   ├── cheby2()         # Chebyshev II
│   ├── ellip()          # 椭圆滤波器
│   └── bessel()         # Bessel
│
├── 信号滤波
│   ├── filtfilt()       # 零相位滤波
│   ├── lfilter()        # 直接滤波
│   ├── sosfilt()        # 二阶节滤波
│   └── wiener()         # Wiener 滤波
│
├── 频谱分析
│   ├── periodogram()    # 周期图
│   ├── welch()          # Welch 方法
│   ├── spectrogram()    # 时频谱
│   └── stft()           # 短时傅里叶变换
│
├── 卷积与相关
│   ├── convolve()       # 卷积
│   ├── correlate()      # 互相关
│   └── fftconvolve()    # FFT 卷积
│
└── 特征提取
    ├── find_peaks()     # 峰值检测
    ├── peak_widths()    # 峰宽
    └── hilbert()        # Hilbert 变换
```

## 2. 滤波器设计

### 2.1 IIR 滤波器

#### 2.1.1 Butterworth 滤波器

**平坦的通带响应**：

```python
from scipy import signal
import numpy as np

# 设计低通滤波器
# fs: 采样频率, fc: 截止频率
fs = 1000  # Hz
fc = 100   # Hz

# 归一化截止频率
Wn = fc / (fs / 2)

# 设计 4 阶 Butterworth 低通滤波器
b, a = signal.butter(4, Wn, btype='low', analog=False)

# 或使用二阶节（推荐，更稳定）
sos = signal.butter(4, Wn, btype='low', analog=False, output='sos')
```

#### 2.1.2 不同类型的滤波器

```python
# 高通滤波器
sos = signal.butter(4, Wn, btype='high', output='sos')

# 带通滤波器
Wn = [50 / (fs/2), 150 / (fs/2)]
sos = signal.butter(4, Wn, btype='band', output='sos')

# 带阻滤波器
sos = signal.butter(4, Wn, btype='bandstop', output='sos')
```

#### 2.1.3 其他 IIR 滤波器

```python
# Chebyshev I（通带波纹）
sos = signal.cheby1(4, 1, Wn, output='sos')  # 1 dB 波纹

# Chebyshev II（阻带波纹）
sos = signal.cheby2(4, 40, Wn, output='sos')  # 40 dB 衰减

# 椭圆滤波器（两个通带都有波纹，最陡峭）
sos = signal.ellip(4, 1, 40, Wn, output='sos')

# Bessel（线性相位）
sos = signal.bessel(4, Wn, output='sos')
```

### 2.2 FIR 滤波器

#### 2.2.1 firwin - 窗函数法

```python
# 设计 FIR 低通滤波器
numtaps = 101  # 滤波器长度（奇数）
fir_coeff = signal.firwin(numtaps, fc, fs=fs)

# 带通滤波器
fir_coeff = signal.firwin(numtaps, [50, 150], pass_zero=False, fs=fs)
```

#### 2.2.2 remez - Parks-McClellan 算法

```python
# 最优 FIR 滤波器
fir_coeff = signal.remez(numtaps, [0, 80, 120, fs/2], [1, 0], fs=fs)
```

### 2.3 滤波器分析

```python
# 频率响应
w, h = signal.freqz(b, a, worN=2000, fs=fs)

# 或对于 SOS
w, h = signal.sosfreqz(sos, worN=2000, fs=fs)

# 绘图
import matplotlib.pyplot as plt

plt.figure(figsize=(12, 4))

# 幅度响应
plt.subplot(1, 2, 1)
plt.plot(w, 20 * np.log10(abs(h)))
plt.xlabel('Frequency (Hz)')
plt.ylabel('Magnitude (dB)')
plt.grid()

# 相位响应
plt.subplot(1, 2, 2)
plt.plot(w, np.angle(h))
plt.xlabel('Frequency (Hz)')
plt.ylabel('Phase (radians)')
plt.grid()

plt.tight_layout()
plt.show()
```

## 3. 信号滤波

### 3.1 使用滤波器

```python
# 生成测试信号
t = np.linspace(0, 1, fs, endpoint=False)
x = np.sin(2 * np.pi * 50 * t) + 0.5 * np.sin(2 * np.pi * 120 * t)
x += np.random.normal(0, 0.1, len(t))  # 添加噪声

# 方法 1: lfilter（因果滤波）
y = signal.lfilter(b, a, x)

# 方法 2: sosfilt（使用二阶节，更稳定）
y = signal.sosfilt(sos, x)

# 方法 3: filtfilt（零相位滤波，推荐）
y = signal.filtfilt(b, a, x)

# 或使用 SOS
y = signal.sosfiltfilt(sos, x)
```

**区别**：
- `lfilter`: 因果滤波，有相位延迟
- `filtfilt`: 前向后向滤波，零相位延迟，但需要整个信号
- `sosfilt`: 使用二阶节，数值更稳定

### 3.2 实时滤波

```python
# 使用 lfilter_zi 初始化滤波器状态
zi = signal.lfilter_zi(b, a) * x[0]

# 分段滤波
y = np.zeros_like(x)
for i in range(0, len(x), 100):
    chunk = x[i:i+100]
    y[i:i+100], zi = signal.lfilter(b, a, chunk, zi=zi)
```

### 3.3 重采样

```python
# 上采样和下采样
y = signal.resample(x, 2000)  # 重采样到 2000 个点

# 按因子重采样
y = signal.resample_poly(x, up=2, down=1)  # 上采样 2 倍

# 抗混叠下采样
y = signal.decimate(x, q=2)  # 下采样 2 倍
```

## 4. 频谱分析

### 4.1 周期图

```python
# 周期图（功率谱密度估计）
f, Pxx = signal.periodogram(x, fs)

plt.semilogy(f, Pxx)
plt.xlabel('Frequency (Hz)')
plt.ylabel('PSD (V**2/Hz)')
plt.show()
```

### 4.2 Welch 方法

**平均周期图，减少方差**：

```python
# Welch 方法
f, Pxx = signal.welch(x, fs, nperseg=256)

plt.semilogy(f, Pxx)
plt.xlabel('Frequency (Hz)')
plt.ylabel('PSD (V**2/Hz)')
plt.show()
```

### 4.3 时频分析

#### 4.3.1 短时傅里叶变换（STFT）

```python
# STFT
f, t, Zxx = signal.stft(x, fs, nperseg=256)

# 绘制时频图
plt.pcolormesh(t, f, np.abs(Zxx), shading='gouraud')
plt.ylabel('Frequency (Hz)')
plt.xlabel('Time (sec)')
plt.colorbar()
plt.show()

# 逆 STFT
t_inv, x_inv = signal.istft(Zxx, fs)
```

#### 4.3.2 频谱图

```python
# 频谱图（spectrogram = |STFT|^2）
f, t, Sxx = signal.spectrogram(x, fs, nperseg=256)

plt.pcolormesh(t, f, 10 * np.log10(Sxx), shading='gouraud')
plt.ylabel('Frequency (Hz)')
plt.xlabel('Time (sec)')
plt.colorbar(label='Power (dB)')
plt.show()
```

### 4.4 连续小波变换

```python
# 使用 cwt（需要定义小波）
from scipy import signal

widths = np.arange(1, 31)
cwtmatr = signal.cwt(x, signal.ricker, widths)

plt.imshow(cwtmatr, extent=[0, 1, 1, 31], cmap='PRGn', aspect='auto',
           vmax=abs(cwtmatr).max(), vmin=-abs(cwtmatr).max())
plt.show()
```

## 5. 卷积和相关

### 5.1 卷积

```python
# 一维卷积
sig = np.array([1, 2, 3, 4, 5])
kernel = np.array([1, 1, 1]) / 3  # 移动平均

# 卷积
conv_result = signal.convolve(sig, kernel, mode='same')

# FFT 卷积（大信号更快）
conv_result = signal.fftconvolve(sig, kernel, mode='same')

# 二维卷积
from scipy import signal

image = np.random.rand(100, 100)
kernel = np.array([[1, 2, 1], [2, 4, 2], [1, 2, 1]]) / 16

filtered = signal.convolve2d(image, kernel, mode='same')
```

### 5.2 相关

```python
# 互相关
sig1 = np.array([1, 2, 3, 4, 5])
sig2 = np.array([1, 1, 1])

corr = signal.correlate(sig1, sig2, mode='same')

# 自相关
autocorr = signal.correlate(sig1, sig1, mode='same')
```

## 6. 峰值检测

### 6.1 find_peaks - 查找峰值

```python
# 生成带峰值的信号
x = np.sin(2 * np.pi * 5 * t) + np.sin(2 * np.pi * 10 * t)

# 查找峰值
peaks, properties = signal.find_peaks(x, height=0.5, distance=20)

# 可视化
plt.plot(t, x)
plt.plot(t[peaks], x[peaks], "x")
plt.show()
```

### 6.2 峰值属性

```python
# 更多属性
peaks, properties = signal.find_peaks(x, 
                                     height=0.5,      # 最小高度
                                     threshold=None,   # 阈值
                                     distance=20,      # 最小距离
                                     prominence=0.3,   # 显著性
                                     width=10)         # 最小宽度

# 提取属性
heights = properties['peak_heights']
prominences = properties['prominences']
widths = properties['widths']
```

### 6.3 峰值宽度和显著性

```python
# 计算峰宽
widths, width_heights, left_ips, right_ips = signal.peak_widths(x, peaks, rel_height=0.5)

# 计算显著性
prominences, left_bases, right_bases = signal.peak_prominences(x, peaks)
```

## 7. 窗函数

```python
# 各种窗函数
N = 51

hann_window = signal.hann(N)
hamming_window = signal.hamming(N)
blackman_window = signal.blackman(N)
kaiser_window = signal.kaiser(N, beta=14)
tukey_window = signal.tukey(N, alpha=0.5)

# 可视化
plt.figure(figsize=(10, 4))
plt.plot(hann_window, label='Hann')
plt.plot(hamming_window, label='Hamming')
plt.plot(blackman_window, label='Blackman')
plt.plot(kaiser_window, label='Kaiser')
plt.legend()
plt.show()
```

## 8. LTI 系统分析

### 8.1 传递函数

```python
# 定义 LTI 系统（传递函数形式）
num = [1, 2]  # 分子
den = [1, 2, 1]  # 分母

sys = signal.TransferFunction(num, den)

# 或使用状态空间形式
A = [[-2, -1], [1, 0]]
B = [[1], [0]]
C = [[1, 0]]
D = [[0]]

sys = signal.StateSpace(A, B, C, D)
```

### 8.2 系统响应

```python
# 脉冲响应
t, y = signal.impulse(sys)

# 阶跃响应
t, y = signal.step(sys)

# 频率响应
w, mag, phase = signal.bode(sys)

# 输出响应（给定输入）
t = np.linspace(0, 5, 500)
u = np.sin(t)
tout, y, x = signal.lsim(sys, u, t)
```

## 9. scipy.ndimage - 多维图像处理

### 9.1 简介

`scipy.ndimage` 提供 **n 维图像处理**，主要用于：
- 图像滤波
- 形态学操作
- 几何变换
- 特征测量

### 9.2 图像滤波

#### 9.2.1 卷积滤波

```python
from scipy import ndimage
import numpy as np

# 2D 图像
image = np.random.rand(100, 100)

# 高斯滤波
smoothed = ndimage.gaussian_filter(image, sigma=2)

# 均值滤波
uniform = ndimage.uniform_filter(image, size=5)

# 中值滤波
median = ndimage.median_filter(image, size=5)

# 自定义卷积核
kernel = np.array([[1, 2, 1], [2, 4, 2], [1, 2, 1]]) / 16
convolved = ndimage.convolve(image, kernel)
```

#### 9.2.2 边缘检测

```python
# Sobel 滤波器（梯度）
sobel_x = ndimage.sobel(image, axis=0)
sobel_y = ndimage.sobel(image, axis=1)
magnitude = np.hypot(sobel_x, sobel_y)

# Laplacian
laplacian = ndimage.laplace(image)

# Prewitt 滤波器
prewitt_x = ndimage.prewitt(image, axis=0)
```

### 9.3 形态学操作

```python
# 二值图像
binary = image > 0.5

# 膨胀
dilated = ndimage.binary_dilation(binary)

# 腐蚀
eroded = ndimage.binary_erosion(binary)

# 开运算（先腐蚀后膨胀）
opened = ndimage.binary_opening(binary)

# 闭运算（先膨胀后腐蚀）
closed = ndimage.binary_closing(binary)

# 填充孔洞
filled = ndimage.binary_fill_holes(binary)
```

### 9.4 几何变换

```python
# 旋转
rotated = ndimage.rotate(image, angle=45, reshape=False)

# 平移
shifted = ndimage.shift(image, shift=[10, 20])

# 缩放
zoomed = ndimage.zoom(image, zoom=2.0)

# 仿射变换
matrix = [[1.1, 0.1], [0.1, 1.1]]
transformed = ndimage.affine_transform(image, matrix)
```

### 9.5 测量和标记

```python
# 连通分量标记
labeled, num_features = ndimage.label(binary)

# 查找对象
objects = ndimage.find_objects(labeled)

# 测量属性
sizes = ndimage.sum(binary, labeled, range(1, num_features + 1))
centers = ndimage.center_of_mass(image, labeled, range(1, num_features + 1))

# 区域统计
means = ndimage.mean(image, labeled, range(1, num_features + 1))
maxima = ndimage.maximum(image, labeled, range(1, num_features + 1))
```

### 9.6 插值

```python
# 3D 图像插值
volume = np.random.rand(10, 20, 30)

# 坐标插值
coords = [[5, 10, 15], [5, 10, 15]]
value = ndimage.map_coordinates(volume, coords, order=3)

# 样条插值
spline = ndimage.spline_filter(image)
```

## 10. scipy.fft - 快速傅里叶变换

### 10.1 一维 FFT

```python
from scipy import fft
import numpy as np

# 信号
N = 1000
T = 1.0 / 800.0  # 采样间隔
t = np.linspace(0.0, N*T, N, endpoint=False)
x = np.sin(50.0 * 2.0*np.pi*t) + 0.5*np.sin(80.0 * 2.0*np.pi*t)

# FFT
yf = fft.fft(x)

# 频率轴
xf = fft.fftfreq(N, T)

# 绘制
plt.plot(xf[:N//2], 2.0/N * np.abs(yf[:N//2]))
plt.xlabel('Frequency (Hz)')
plt.ylabel('Magnitude')
plt.show()

# 逆 FFT
x_reconstructed = fft.ifft(yf)
```

### 10.2 实数 FFT（更高效）

```python
# 对于实数信号，使用 rfft
yf = fft.rfft(x)
xf = fft.rfftfreq(N, T)

# 逆变换
x_reconstructed = fft.irfft(yf)
```

### 10.3 多维 FFT

```python
# 2D FFT
image = np.random.rand(100, 100)
fft2d = fft.fft2(image)

# 逆变换
image_reconstructed = fft.ifft2(fft2d)

# n 维 FFT
volume = np.random.rand(10, 20, 30)
fftn = fft.fftn(volume)
```

### 10.4 离散余弦变换（DCT）

```python
# DCT
y = fft.dct(x, type=2, norm='ortho')

# 逆 DCT
x_reconstructed = fft.idct(y, type=2, norm='ortho')
```

## 11. 实用案例

### 11.1 去除信号中的特定频率

```python
from scipy import signal, fft
import numpy as np

# 生成信号（50 Hz 噪声）
fs = 1000
t = np.linspace(0, 1, fs)
x = np.sin(2 * np.pi * 5 * t) + 0.5 * np.sin(2 * np.pi * 50 * t)

# 设计陷波滤波器（notch filter）
f0 = 50  # 陷波频率
Q = 30   # 品质因子
b, a = signal.iirnotch(f0, Q, fs)

# 滤波
y = signal.filtfilt(b, a, x)
```

### 11.2 图像锐化

```python
from scipy import ndimage
import numpy as np

# 读取图像（这里用随机数据）
image = np.random.rand(256, 256)

# 高斯模糊
blurred = ndimage.gaussian_filter(image, sigma=2)

# 锐化 = 原图 + α * (原图 - 模糊图)
alpha = 1.5
sharpened = image + alpha * (image - blurred)
sharpened = np.clip(sharpened, 0, 1)
```

### 11.3 检测心跳（ECG 信号）

```python
from scipy import signal
import numpy as np

# 生成模拟 ECG 信号
fs = 1000
t = np.linspace(0, 10, fs * 10)
ecg = np.zeros_like(t)

# 添加心跳峰值
beat_times = [1, 2, 3, 4, 5, 6, 7, 8, 9]
for bt in beat_times:
    idx = int(bt * fs)
    if idx < len(ecg) - 50:
        ecg[idx:idx+50] += signal.gaussian(50, std=5)

# 添加噪声
ecg += np.random.normal(0, 0.1, len(ecg))

# 带通滤波（5-15 Hz）
sos = signal.butter(4, [5, 15], btype='band', fs=fs, output='sos')
ecg_filtered = signal.sosfiltfilt(sos, ecg)

# 检测 R 峰
peaks, _ = signal.find_peaks(ecg_filtered, height=0.5, distance=fs*0.6)

# 计算心率
heart_rate = 60 * fs / np.diff(peaks)
print(f"平均心率: {np.mean(heart_rate):.1f} bpm")
```

### 11.4 音频均衡器

```python
from scipy import signal
import numpy as np

# 音频信号（假设采样率 44.1 kHz）
fs = 44100
duration = 5
t = np.linspace(0, duration, fs * duration)

# 设计多频段均衡器
bands = [(20, 250), (250, 1000), (1000, 4000), (4000, 16000)]
gains = [1.5, 1.0, 0.8, 1.2]  # 各频段增益

# 为每个频段设计带通滤波器
audio = np.random.randn(len(t))  # 原始音频
equalized = np.zeros_like(audio)

for (low, high), gain in zip(bands, gains):
    sos = signal.butter(4, [low, high], btype='band', fs=fs, output='sos')
    band_signal = signal.sosfiltfilt(sos, audio)
    equalized += gain * band_signal
```

## 12. 性能优化

### 12.1 FFT 技巧

```python
# 1. 使用 rfft 对于实数信号
yf = fft.rfft(x)  # 比 fft() 快约 2 倍

# 2. 零填充到 2 的幂次
N = len(x)
N_fft = 2**int(np.ceil(np.log2(N)))
yf = fft.fft(x, n=N_fft)  # 更快

# 3. 使用 fftconvolve 对于大卷积核
result = signal.fftconvolve(x, kernel, mode='same')
```

### 12.2 滤波器优化

```python
# 1. 使用二阶节（SOS）而非 b/a
sos = signal.butter(10, 0.1, output='sos')
y = signal.sosfilt(sos, x)  # 更稳定

# 2. 对于大数据，分块处理
chunk_size = 10000
zi = signal.sosfilt_zi(sos) * x[0]

for i in range(0, len(x), chunk_size):
    chunk = x[i:i+chunk_size]
    y[i:i+chunk_size], zi = signal.sosfilt(sos, chunk, zi=zi)
```

## 13. 最佳实践

### 13.1 信号处理

1. **使用二阶节（SOS）** 代替 b/a 系数（更稳定）
2. **filtfilt** 用于零相位滤波（离线）
3. **选择合适的窗函数** 用于频谱分析
4. **Nyquist 频率** 注意采样定理
5. **预处理** 去趋势、归一化

### 13.2 图像处理

1. **归一化** 到 [0, 1] 或 [0, 255]
2. **选择合适的边界处理** 模式
3. **形态学操作** 的结构元素大小
4. **多尺度处理** 金字塔方法

## 14. 总结

**scipy.signal** 提供：
- 完整的滤波器设计工具
- 多种滤波方法
- 频谱分析
- 峰值检测
- LTI 系统分析

**scipy.ndimage** 提供：
- n 维图像滤波
- 形态学操作
- 几何变换
- 特征测量

**scipy.fft** 提供：
- 快速傅里叶变换
- 多维 FFT
- 实数 FFT 优化
- DCT/DST

---

**相关文档**:
- [01_SciPy架构总览.md](01_SciPy架构总览.md)
- [03_优化和求解器.md](03_优化和求解器.md)
- [05_统计和概率.md](05_统计和概率.md)
