# SciPy 线性代数和稀疏矩阵详解

## 1. scipy.linalg - 线性代数

### 1.1 简介

`scipy.linalg` 提供了比 `numpy.linalg` 更完整、更稳定的线性代数功能。它建立在 BLAS 和 LAPACK 之上，提供了高性能的矩阵运算。

**为什么使用 scipy.linalg 而非 numpy.linalg？**
1. 更多功能（特殊矩阵分解、Schur 分解等）
2. 更好的数值稳定性
3. 始终编译 BLAS/LAPACK 支持
4. 更多可选参数

### 1.2 核心功能分类

```
scipy.linalg/
├── 基本线性代数
│   ├── inv()           # 矩阵求逆
│   ├── solve()         # 求解线性系统
│   ├── det()           # 行列式
│   └── lstsq()         # 最小二乘
│
├── 矩阵分解
│   ├── lu()            # LU 分解
│   ├── qr()            # QR 分解
│   ├── svd()           # 奇异值分解
│   ├── cholesky()      # Cholesky 分解
│   ├── schur()         # Schur 分解
│   └── polar()         # 极分解
│
├── 特征值问题
│   ├── eig()           # 特征值和特征向量
│   ├── eigvals()       # 仅特征值
│   ├── eigh()          # 对称/埃尔米特矩阵
│   └── eigvalsh()      # 对称矩阵特征值
│
├── 矩阵函数
│   ├── expm()          # 矩阵指数
│   ├── logm()          # 矩阵对数
│   ├── sqrtm()         # 矩阵平方根
│   └── funm()          # 一般矩阵函数
│
└── 特殊矩阵
    ├── toeplitz()      # Toeplitz 矩阵
    ├── circulant()     # 循环矩阵
    ├── hankel()        # Hankel 矩阵
    └── hilbert()       # Hilbert 矩阵
```

## 2. 基本线性代数运算

### 2.1 求解线性系统

#### 2.1.1 一般线性系统

求解 $Ax = b$：

```python
from scipy import linalg
import numpy as np

A = np.array([[3, 2, 0], [1, -1, 0], [0, 5, 1]])
b = np.array([2, 4, -1])

# 求解
x = linalg.solve(a, b)

# 验证
np.allclose(np.dot(A, x), b)  # True
```

#### 2.1.2 带状矩阵系统

对于带状矩阵（稀疏矩阵的特例）：

```python
from scipy.linalg import solve_banded

# ab: 带状矩阵（特殊存储格式）
# ab[u + i - j, j] = A[i, j]
# u: 上对角线数量

x = solve_banded((l, u), ab, b)
```

#### 2.1.3 对称正定系统

如果 A 是对称正定的，使用 Cholesky 分解更快：

```python
c, low = linalg.cho_factor(A)
x = linalg.cho_solve((c, low), b)
```

#### 2.1.4 三对角系统

```python
from scipy.linalg import solve_triangular

# 求解上三角或下三角系统
x = solve_triangular(A, b, lower=True)  # 下三角
```

### 2.2 矩阵求逆

```python
from scipy import linalg

A = np.array([[1, 2], [3, 4]])

# 求逆
A_inv = linalg.inv(A)

# 验证
np.allclose(np.dot(A, A_inv), np.eye(2))

# 注意：通常不需要显式求逆
# 求解 Ax = b 时，使用 linalg.solve(A, b) 更快更稳定
```

### 2.3 行列式

```python
# 计算行列式
det_A = linalg.det(A)
```

### 2.4 范数

```python
# 矩阵范数
norm_A = linalg.norm(A, ord='fro')  # Frobenius 范数
norm_A = linalg.norm(A, ord=2)      # 谱范数（最大奇异值）
norm_A = linalg.norm(A, ord=np.inf) # 无穷范数
```

## 3. 矩阵分解

### 3.1 LU 分解

$A = PLU$，其中 P 是置换矩阵，L 是下三角，U 是上三角：

```python
from scipy import linalg

A = np.array([[2, 5, 8, 7], [5, 2, 2, 8], [7, 5, 6, 6], [5, 4, 4, 8]])

# LU 分解
P, L, U = linalg.lu(A)

# 验证
np.allclose(A, np.dot(P, np.dot(L, U)))

# 用于求解（更高效）
lu, piv = linalg.lu_factor(A)
x = linalg.lu_solve((lu, piv), b)
```

### 3.2 QR 分解

$A = QR$，其中 Q 是正交矩阵，R 是上三角矩阵：

```python
from scipy import linalg

A = np.random.randn(5, 3)

# QR 分解
Q, R = linalg.qr(A)

# Q 是正交的
np.allclose(np.dot(Q.T, Q), np.eye(Q.shape[1]))

# 验证
np.allclose(A, np.dot(Q, R))

# 经济型 QR（mode='economic'）
Q, R = linalg.qr(A, mode='economic')
```

### 3.3 奇异值分解 (SVD)

$A = U\Sigma V^T$：

```python
from scipy import linalg

A = np.random.randn(4, 3)

# SVD
U, s, Vt = linalg.svd(A)

# s 是奇异值（按降序）
# U, Vt 是正交矩阵

# 重构
S = linalg.diagsvd(s, U.shape[0], Vt.shape[0])
np.allclose(A, np.dot(U, np.dot(S, Vt)))

# 计算条件数
cond = s[0] / s[-1]
```

**应用**：
- 降维
- 伪逆计算
- 矩阵的秩
- 最小二乘问题

### 3.4 Cholesky 分解

对于对称正定矩阵 $A = LL^T$：

```python
from scipy import linalg

# 对称正定矩阵
A = np.array([[4, 2, 1], [2, 9, 3], [1, 3, 16]])

# Cholesky 分解
L = linalg.cholesky(A, lower=True)

# 验证
np.allclose(A, np.dot(L, L.T))

# 上三角形式
U = linalg.cholesky(A, lower=False)
np.allclose(A, np.dot(U.T, U))
```

### 3.5 Schur 分解

$A = ZTZ^T$，其中 T 是上三角（实矩阵）或上三角块（复矩阵）：

```python
from scipy import linalg

T, Z = linalg.schur(A)

# 验证
np.allclose(A, np.dot(Z, np.dot(T, Z.T)))
```

### 3.6 极分解

$A = UP$，其中 U 是酉矩阵，P 是正定埃尔米特矩阵：

```python
U, P = linalg.polar(A)
```

## 4. 特征值问题

### 4.1 一般矩阵

```python
from scipy import linalg

A = np.array([[1, 2], [3, 4]])

# 特征值和特征向量
eigenvalues, eigenvectors = linalg.eig(A)

# 仅特征值
eigenvalues = linalg.eigvals(A)

# 验证: Av = λv
for i in range(len(eigenvalues)):
    lam = eigenvalues[i]
    v = eigenvectors[:, i]
    np.allclose(np.dot(A, v), lam * v)
```

### 4.2 对称/埃尔米特矩阵

对称矩阵的特征值总是实数：

```python
# 对称矩阵
A = np.array([[1, 2, 3], [2, 4, 5], [3, 5, 6]])

# 使用专门的函数（更快更准确）
eigenvalues, eigenvectors = linalg.eigh(A)

# 仅特征值
eigenvalues = linalg.eigvalsh(A)
```

### 4.3 广义特征值问题

求解 $Av = \lambda Bv$：

```python
eigenvalues, eigenvectors = linalg.eig(A, B)
```

## 5. 矩阵函数

### 5.1 矩阵指数

$$e^A = \sum_{k=0}^{\infty} \frac{A^k}{k!}$$

```python
from scipy import linalg

A = np.array([[1, 2], [3, 4]])

# 矩阵指数
expA = linalg.expm(A)

# 应用：求解常微分方程
# dx/dt = Ax, x(0) = x0
# 解: x(t) = exp(At) * x0
```

### 5.2 矩阵对数

```python
# 矩阵对数
logA = linalg.logm(A)

# 验证
np.allclose(linalg.expm(logA), A)
```

### 5.3 矩阵平方根

```python
# 矩阵平方根
sqrtA = linalg.sqrtm(A)

# 验证
np.allclose(np.dot(sqrtA, sqrtA), A)
```

### 5.4 一般矩阵函数

```python
# 自定义矩阵函数
def f(x):
    return x**2 + 2*x + 1

fA = linalg.funm(A, f)
```

## 6. 特殊矩阵

### 6.1 生成特殊矩阵

```python
from scipy import linalg

# Toeplitz 矩阵（对角线上的元素相同）
T = linalg.toeplitz([1, 2, 3, 4], [1, 5, 6, 7])

# 循环矩阵
C = linalg.circulant([1, 2, 3, 4])

# Hankel 矩阵
H = linalg.hankel([1, 2, 3, 4], [4, 7, 7, 8])

# Hilbert 矩阵（病态矩阵）
H = linalg.hilbert(5)
```

## 7. scipy.sparse - 稀疏矩阵

### 7.1 简介

稀疏矩阵是指大部分元素为零的矩阵。存储稀疏矩阵的完整形式会浪费大量内存。

**何时使用稀疏矩阵？**
- 矩阵很大且大部分元素为零
- 有限元分析
- 图算法
- 文本处理（TF-IDF 矩阵）
- 网络分析

### 7.2 稀疏矩阵格式

```python
from scipy import sparse
import numpy as np

# 创建示例数据
row = np.array([0, 0, 1, 2, 2, 2])
col = np.array([0, 2, 2, 0, 1, 2])
data = np.array([1, 2, 3, 4, 5, 6])
```

#### 7.2.1 COO (Coordinate) - 坐标格式

**最简单的格式**，存储非零元素的坐标：

```python
# COO 格式
coo = sparse.coo_matrix((data, (row, col)), shape=(3, 3))

print(coo.toarray())
# [[1 0 2]
#  [0 0 3]
#  [4 5 6]]

# 特点：
# - 易于构建
# - 不支持算术运算
# - 不支持切片
# - 适合构建后转换为其他格式
```

#### 7.2.2 CSR (Compressed Sparse Row) - 压缩稀疏行

**最常用的格式**，高效的行切片和矩阵-向量乘法：

```python
# CSR 格式
csr = sparse.csr_matrix((data, (row, col)), shape=(3, 3))

# 或从 COO 转换
csr = coo.tocsr()

# 特点：
# - 高效的行切片
# - 高效的矩阵-向量乘法
# - 快速算术运算
# - 慢的列切片和元素添加
```

#### 7.2.3 CSC (Compressed Sparse Column) - 压缩稀疏列

**类似 CSR**，但按列压缩：

```python
# CSC 格式
csc = sparse.csc_matrix((data, (row, col)), shape=(3, 3))

# 特点：
# - 高效的列切片
# - 高效的矩阵-向量乘法
# - 适合列操作
```

#### 7.2.4 其他格式

```python
# LIL (List of Lists) - 易于增量构建
lil = sparse.lil_matrix((1000, 1000))
lil[0, :100] = np.random.rand(100)
lil[1, 100:200] = np.random.rand(100)

# DOK (Dictionary of Keys) - 易于元素访问
dok = sparse.dok_matrix((1000, 1000))
dok[0, 0] = 1
dok[500, 500] = 2

# DIA (Diagonal) - 对角矩阵
dia = sparse.diags([1, 2, 3], offsets=[0, 1, -1], shape=(5, 5))

# BSR (Block Sparse Row) - 块稀疏行
```

### 7.3 创建稀疏矩阵

```python
from scipy import sparse

# 1. 从密集矩阵
dense = np.array([[1, 0, 0], [0, 2, 0], [0, 0, 3]])
sp = sparse.csr_matrix(dense)

# 2. 单位矩阵
I = sparse.eye(1000, format='csr')

# 3. 对角矩阵
diag = sparse.diags([1, 2, 3, 4], offsets=0)

# 4. 随机稀疏矩阵
random_sp = sparse.random(1000, 1000, density=0.01, format='csr')

# 5. 空矩阵
empty_sp = sparse.csr_matrix((1000, 1000))
```

### 7.4 稀疏矩阵运算

```python
from scipy import sparse

A = sparse.random(1000, 1000, density=0.01, format='csr')
B = sparse.random(1000, 1000, density=0.01, format='csr')

# 加法
C = A + B

# 乘法
C = A * B  # 矩阵乘法
C = A.multiply(B)  # 逐元素乘法

# 标量运算
C = A * 2
C = A + 5  # 会变成密集矩阵！

# 矩阵-向量乘法
x = np.random.rand(1000)
y = A.dot(x)

# 转置
At = A.T
At = A.transpose()
```

### 7.5 稀疏矩阵属性

```python
# 形状
print(A.shape)

# 非零元素数量
print(A.nnz)

# 稀疏度
sparsity = 1.0 - A.nnz / (A.shape[0] * A.shape[1])

# 转换为密集矩阵（小心内存！）
dense = A.toarray()
dense = A.todense()  # 返回 np.matrix

# 转换格式
csr = A.tocsr()
csc = A.tocsc()
coo = A.tocoo()
```

### 7.6 稀疏线性代数

```python
from scipy.sparse import linalg

# 稀疏矩阵
A = sparse.random(1000, 1000, density=0.01, format='csr')
b = np.random.rand(1000)

# 1. 直接求解（对称正定）
x = linalg.spsolve(A, b)

# 2. 迭代求解器
x, info = linalg.cg(A, b)  # 共轭梯度（对称正定）
x, info = linalg.gmres(A, b)  # GMRES（一般矩阵）
x, info = linalg.bicgstab(A, b)  # BiCGSTAB

# 3. 特征值（稀疏）
eigenvalues, eigenvectors = linalg.eigs(A, k=6)  # 最大的 6 个特征值

# 4. 奇异值（稀疏）
u, s, vt = linalg.svds(A, k=6)  # 最大的 6 个奇异值

# 5. 范数
norm = linalg.norm(A)
```

### 7.7 稀疏矩阵构建技巧

```python
from scipy import sparse

# 1. 使用 LIL 增量构建，然后转换为 CSR
lil = sparse.lil_matrix((10000, 10000))
for i in range(10000):
    lil[i, i] = 1.0
    if i > 0:
        lil[i, i-1] = -0.5
    if i < 9999:
        lil[i, i+1] = -0.5

csr = lil.tocsr()  # 转换为 CSR 用于计算

# 2. 使用 COO 一次性构建
rows = []
cols = []
data = []

for i in range(10000):
    rows.append(i); cols.append(i); data.append(1.0)
    if i > 0:
        rows.append(i); cols.append(i-1); data.append(-0.5)
    if i < 9999:
        rows.append(i); cols.append(i+1); data.append(-0.5)

coo = sparse.coo_matrix((data, (rows, cols)), shape=(10000, 10000))
csr = coo.tocsr()

# 3. 使用 diags 构建带状矩阵
diagonals = [np.ones(10000), -0.5 * np.ones(9999), -0.5 * np.ones(9999)]
offsets = [0, -1, 1]
A = sparse.diags(diagonals, offsets, format='csr')
```

## 8. 实用案例

### 8.1 求解大型稀疏线性系统

```python
from scipy.sparse import diags, linalg
import numpy as np

# 创建大型三对角矩阵（Laplacian）
n = 10000
diagonals = [2 * np.ones(n), -np.ones(n-1), -np.ones(n-1)]
A = diags(diagonals, [0, -1, 1], format='csr')

# 右侧向量
b = np.ones(n)

# 使用迭代求解器
x, info = linalg.cg(A, b, tol=1e-6)

if info == 0:
    print("求解成功")
    print(f"残差: {np.linalg.norm(A.dot(x) - b)}")
```

### 8.2 主成分分析（稀疏版）

```python
from scipy.sparse import linalg
import numpy as np

# 稀疏数据矩阵
X = sparse.random(1000, 500, density=0.01, format='csr')

# 计算协方差矩阵的最大特征值/向量
# (避免形成密集协方差矩阵)
u, s, vt = linalg.svds(X, k=10)

# 主成分
principal_components = vt
```

### 8.3 图的 Laplacian 矩阵

```python
from scipy import sparse

# 邻接矩阵（图）
n = 100
A = sparse.random(n, n, density=0.05, format='csr')
A = A + A.T  # 对称化

# 度矩阵
degrees = np.array(A.sum(axis=1)).flatten()
D = sparse.diags(degrees)

# Laplacian 矩阵
L = D - A

# 计算第二小的特征值（Fiedler 值）
eigenvalues, eigenvectors = sparse.linalg.eigsh(L, k=2, which='SM')
fiedler_value = eigenvalues[1]
```

## 9. 性能比较

### 9.1 scipy.linalg vs numpy.linalg

```python
import numpy as np
from scipy import linalg as sp_linalg
import time

A = np.random.randn(1000, 1000)
b = np.random.randn(1000)

# NumPy
start = time.time()
x_np = np.linalg.solve(A, b)
time_np = time.time() - start

# SciPy
start = time.time()
x_sp = sp_linalg.solve(A, b)
time_sp = time.time() - start

print(f"NumPy: {time_np:.4f}s")
print(f"SciPy: {time_sp:.4f}s")
# SciPy 通常更快，特别是对于大矩阵
```

### 9.2 密集 vs 稀疏

```python
# 密集矩阵
dense_A = np.random.randn(5000, 5000)

# 稀疏矩阵（1% 密度）
sparse_A = sparse.random(5000, 5000, density=0.01, format='csr')

# 内存使用
print(f"密集矩阵: {dense_A.nbytes / 1e6:.1f} MB")
print(f"稀疏矩阵: {(sparse_A.data.nbytes + sparse_A.indices.nbytes + sparse_A.indptr.nbytes) / 1e6:.1f} MB")
```

## 10. 最佳实践

### 10.1 选择合适的稀疏格式

| 操作 | 推荐格式 |
|-----|---------|
| 构建 | LIL, DOK, COO |
| 算术运算 | CSR, CSC |
| 行切片 | CSR |
| 列切片 | CSC |
| 矩阵-向量乘法 | CSR, CSC |
| 稀疏-稀疏乘法 | CSR, CSC |

### 10.2 避免密集化

```python
# 错误：会创建密集矩阵
A_dense = A + 5

# 正确：保持稀疏
A_shifted = A.copy()
A_shifted.data += 5
```

### 10.3 线性求解器选择

| 矩阵类型 | 推荐方法 |
|---------|---------|
| 小型密集 | `linalg.solve()` |
| 对称正定 | `linalg.cho_solve()` |
| 稀疏对称正定 | `sparse.linalg.cg()` |
| 稀疏一般 | `sparse.linalg.spsolve()`, `gmres()` |

## 11. 总结

**scipy.linalg** 提供：
- 完整的线性代数功能
- 比 NumPy 更多的分解和特殊矩阵
- 更好的数值稳定性
- BLAS/LAPACK 优化

**scipy.sparse** 提供：
- 多种稀疏矩阵格式
- 内存高效存储
- 稀疏线性代数
- 适合大规模问题

---

**相关文档**:
- [01_SciPy架构总览.md](01_SciPy架构总览.md)
- [03_优化和求解器.md](03_优化和求解器.md)
- [05_统计和概率.md](05_统计和概率.md)
