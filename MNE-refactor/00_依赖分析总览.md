# MNE-Python 依赖分析总览

## 目标

本系列文档旨在深入分析 MNE-Python 1.1.10 的依赖关系，为使用 Rust 完全重写该框架提供详细的技术指导。

**最终目标**: 创建一个纯 Rust 的脑电/脑磁数据处理框架，完全替代 Python 依赖，提供更高性能和更好的类型安全性。

---

## 依赖层次结构

### 核心依赖（Critical Dependencies）

```
MNE-Python
├── NumPy (必需 - 数组计算基础)
│   ├── 核心数组操作
│   ├── 线性代数 (np.linalg)
│   ├── FFT (np.fft)
│   ├── 随机数生成 (np.random)
│   └── 多项式 (np.polynomial)
│
├── SciPy (必需 - 科学计算)
│   ├── scipy.linalg (线性代数进阶)
│   ├── scipy.sparse (稀疏矩阵)
│   ├── scipy.signal (信号处理)
│   ├── scipy.stats (统计函数)
│   ├── scipy.fft (FFT进阶)
│   ├── scipy.ndimage (图像处理)
│   ├── scipy.interpolate (插值)
│   ├── scipy.optimize (优化算法)
│   └── scipy.spatial (空间算法)
│
└── scikit-learn (必需 - 机器学习)
    ├── 分类器 (ICA 组件分类)
    ├── 降维 (PCA, ICA)
    ├── 聚类
    └── 预处理工具
```

### 次要依赖（Secondary Dependencies）

```
├── matplotlib (可视化)
├── pandas (数据处理)  
├── h5py/h5io (HDF5 数据格式)
├── nibabel (MRI 数据)
├── nilearn (神经影像)
└── pooch (数据下载)
```

### 依赖使用频率统计

基于代码扫描结果：

| 依赖库 | 导入次数 | 使用模块数 | 关键程度 |
|-------|---------|-----------|---------|
| NumPy | 200+ | 几乎所有 | ⭐⭐⭐⭐⭐ |
| SciPy | 150+ | 80%+ | ⭐⭐⭐⭐⭐ |
| scikit-learn | 30+ | 30% | ⭐⭐⭐⭐ |
| matplotlib | 50+ | 可视化模块 | ⭐⭐⭐ |
| pandas | 20+ | 数据导入/导出 | ⭐⭐ |

---

## 核心功能模块映射

### 1. 数据 I/O 模块 (`mne/io/`)

**依赖**:
- NumPy: 数组存储和操作
- SciPy: 
  - `scipy.io.loadmat` (MATLAB 文件)
  - `scipy.sparse` (稀疏存储)

**关键功能**:
- 读取多种 EEG/MEG 格式 (FIF, EDF, BDF, GDF, etc.)
- 数据转换和缓存
- 实时数据流

### 2. 预处理模块 (`mne/preprocessing/`)

**依赖**:
- NumPy: 基础数组操作
- SciPy:
  - `scipy.signal` (滤波、重采样)
  - `scipy.linalg` (矩阵分解)
  - `scipy.stats` (统计检验)
  - `scipy.optimize` (优化算法)
  - `scipy.interpolate` (插值)
- scikit-learn: ICA, PCA

**关键功能**:
- **滤波**: 
  - `scipy.signal.butter`, `filtfilt`
  - IIR/FIR 滤波器设计
- **ICA** (独立成分分析):
  - `sklearn.decomposition.FastICA`
  - Infomax 算法 (自实现 + scipy)
- **Maxwell 滤波**:
  - `scipy.linalg` (矩阵运算)
  - `scipy.special.lpmv` (Legendre 多项式)
- **坏道插值**:
  - `scipy.interpolate`
  - `scipy.spatial.distance`
- **nIRS 数据处理**:
  - Beer-Lambert 定律实现
  - `scipy.interpolate.interp1d`

### 3. Epoching 和事件处理 (`mne/epochs.py`, `mne/event.py`)

**依赖**:
- NumPy: 数组切片和索引
- SciPy:
  - `scipy.signal` (事件检测)
  - `scipy.ndimage` (标记)

**关键功能**:
- 事件标记和提取
- 基线校正
- 去趋势

### 4. 时频分析 (`mne/time_frequency/`)

**依赖**:
- NumPy: `np.fft`
- SciPy:
  - `scipy.fft` (快速傅里叶变换)
  - `scipy.signal` (STFT, 小波)

**关键功能**:
- 功率谱密度 (PSD)
- 时频表示 (TFR)
- Morlet 小波
- Hilbert 变换

### 5. 源估计 (`mne/forward/`, `mne/minimum_norm/`, `mne/beamformer/`)

**依赖**:
- NumPy: `np.linalg` (线性代数)
- SciPy:
  - `scipy.linalg` (SVD, 特征值分解)
  - `scipy.sparse` (大型稀疏矩阵)
  - `scipy.spatial` (空间算法)
  - `scipy.optimize` (优化)

**关键功能**:
- **正向模型**:
  - BEM (边界元方法)
  - Leadfield 矩阵计算
  - `scipy.spatial.Delaunay` (三角剖分)
- **逆解**:
  - MNE (最小范数估计): `scipy.linalg.svd`
  - dSPM, sLORETA, eLORETA
  - `scipy.linalg.eigh` (特征分解)
- **Beamformer**:
  - LCMV, DICS
  - 协方差矩阵计算

### 6. 统计分析 (`mne/stats/`)

**依赖**:
- NumPy: 基础统计
- SciPy:
  - `scipy.stats` (t检验, F检验)
  - `scipy.sparse.csgraph` (图论)
  - `scipy.ndimage` (聚类标记)

**关键功能**:
- 簇级别置换检验
- 多重比较校正
- 时空聚类
- `scipy.sparse.csgraph.connected_components`

### 7. 解码和分类 (`mne/decoding/`)

**依赖**:
- scikit-learn: 核心机器学习
- NumPy/SciPy: 数值计算

**关键功能**:
- CSP (共同空间模式)
- 时间解码
- 交叉验证

### 8. 可视化 (`mne/viz/`)

**依赖**:
- matplotlib (主要)
- NumPy/SciPy (数据准备)

**关键功能**:
- 拓扑图
- ERP 图
- 时频图
- 源空间可视化

---

## 依赖使用模式分析

### NumPy 使用模式

#### 1. 数组操作 (无处不在)
```python
# 随处可见的模式
import numpy as np

# 数组创建和初始化
data = np.zeros((n_channels, n_times))
data = np.empty((n_epochs, n_channels, n_times))

# 数组索引和切片  
epochs = data[:, picks, start:stop]

# 广播和向量化
normalized = (data - mean) / std

# 聚合操作
avg = np.mean(data, axis=0)
```

#### 2. 线性代数 (`np.linalg` - 高频使用)
```python
# 范数计算
norm = np.linalg.norm(vector, axis=-1)

# 矩阵求逆
inv_matrix = np.linalg.inv(matrix)

# 特征值分解
eigenvalues, eigenvectors = np.linalg.eigh(cov_matrix)

# SVD
U, s, Vt = np.linalg.svd(data, full_matrices=False)
```

#### 3. FFT (`np.fft` - 时频分析核心)
```python
# 快速傅里叶变换
fft_data = np.fft.rfft(data, n=n_fft)
freqs = np.fft.rfftfreq(n_samples, d=1.0/sfreq)

# 逆变换
time_data = np.fft.irfft(fft_data)
```

#### 4. 随机数 (`np.random` - 仿真和统计)
```python
# 传统接口
rng = np.random.RandomState(seed)
noise = rng.randn(n_samples)

# 新式接口
rng = np.random.default_rng(seed)
samples = rng.normal(loc=0, scale=1, size=shape)
```

### SciPy 使用模式

#### 1. 信号处理 (`scipy.signal` - 预处理核心)
```python
from scipy.signal import butter, filtfilt, hilbert

# 滤波器设计
sos = butter(4, [l_freq, h_freq], btype='band', fs=sfreq, output='sos')

# 零相位滤波
filtered = filtfilt(b, a, data)

# Hilbert 变换
analytic = hilbert(data, axis=-1)
```

#### 2. 线性代数 (`scipy.linalg` - 比 np.linalg 更强大)
```python
from scipy.linalg import eigh, svd, pinv

# 广义特征值问题
eigenvalues, eigenvectors = eigh(A, B)

# 伪逆
pseudo_inv = pinv(matrix)

# 更稳定的 SVD
U, s, Vt = svd(matrix, full_matrices=False, lapack_driver='gesvd')
```

#### 3. 稀疏矩阵 (`scipy.sparse` - 大规模问题)
```python
from scipy.sparse import csr_array, csc_array
from scipy.sparse.csgraph import dijkstra, connected_components

# 稀疏矩阵创建
adjacency = csr_array((data, (row, col)), shape=(n, n))

# 图算法
dist_matrix = dijkstra(adjacency)
n_components, labels = connected_components(adjacency)
```

#### 4. 统计 (`scipy.stats` - 假设检验)
```python
from scipy.stats import t, f, zscore, pearsonr

# t 检验
t_stat, p_value = ttest_ind(group1, group2)

# Z-score 标准化
z_data = zscore(data, axis=0)

# 相关性
r, p = pearsonr(x, y)
```

#### 5. 优化 (`scipy.optimize` - 参数估计)
```python
from scipy.optimize import minimize, fmin_cobyla

# 优化
result = minimize(objective, x0, method='BFGS')

# 约束优化
result = fmin_cobyla(func, x0, constraints)
```

#### 6. 插值 (`scipy.interpolate`)
```python
from scipy.interpolate import interp1d, RectBivariateSpline

# 1D 插值
f = interp1d(x, y, kind='cubic')
y_new = f(x_new)

# 2D 插值
f = RectBivariateSpline(x, y, z)
```

### scikit-learn 使用模式

#### 1. ICA (独立成分分析 - 伪影去除核心)
```python
from sklearn.decomposition import FastICA

# ICA 分解
ica = FastICA(n_components=n_components, random_state=0)
sources = ica.fit_transform(data.T).T
mixing = ica.mixing_
```

#### 2. PCA (降维)
```python
from sklearn.decomposition import PCA

pca = PCA(n_components=n_components)
transformed = pca.fit_transform(data)
```

#### 3. 分类 (ICA 组件分类)
```python
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC

clf = RandomForestClassifier(random_state=0)
clf.fit(X_train, y_train)
predictions = clf.predict(X_test)
```

---

## 关键算法实现分析

### 1. 滤波器实现 (`mne/filter.py`)

**依赖**: `scipy.signal`

**核心流程**:
```python
# 设计 Butterworth 滤波器
sos = scipy.signal.butter(order, Wn, btype='bandpass', output='sos')

# 零相位滤波
filtered = scipy.signal.sosfiltfilt(sos, data, axis=-1)
```

**Rust 替代方案**: 
- `biquad` crate
- `rustfft` crate
- 自实现 Butterworth/Chebyshev 滤波器

### 2. ICA 实现 (`mne/preprocessing/ica.py`)

**算法**: 
- FastICA (sklearn)
- Infomax (自实现)
- Extended Infomax
- Picard

**核心依赖**:
```python
# FastICA (sklearn)
from sklearn.decomposition import FastICA

# Infomax (自实现 + scipy)
from scipy.stats import kurtosis
from scipy.special import expit  # sigmoid
```

**Rust 替代方案**:
- 自实现 FastICA
- `ndarray-linalg` for 矩阵运算
- `smartcore` (机器学习库)

### 3. 源估计 - MNE 算法 (`mne/minimum_norm/inverse.py`)

**核心数学**:
$$\hat{J} = M \cdot G^T (G \cdot M \cdot G^T + \lambda^2 C)^{-1} \cdot y$$

**依赖**:
```python
# SVD 分解
U, s, Vt = scipy.linalg.svd(gain_matrix)

# 正则化逆解
inv_operator = compute_regularized_inverse(...)
```

**Rust 替代方案**:
- `ndarray-linalg` (LAPACK 绑定)
- `nalgebra` (纯 Rust 线性代数)
- `faer` (快速线性代数)

### 4. 簇级别置换检验 (`mne/stats/cluster_level.py`)

**依赖**:
```python
from scipy.ndimage import label
from scipy.sparse.csgraph import connected_components
from scipy.stats import t, f

# 连通分量标记
n_clusters, labels = connected_components(adjacency)

# 统计检验
t_stat = ttest_ind(data1, data2)
```

**Rust 替代方案**:
- `petgraph` (图算法)
- `statrs` (统计函数)
- 自实现置换检验

### 5. 时频分析 - Morlet 小波 (`mne/time_frequency/tfr.py`)

**依赖**:
```python
import numpy.fft as fft
from scipy.fft import rfft, irfft

# Morlet 小波卷积
wavelet_fft = fft.rfft(morlet_wave)
data_fft = fft.rfft(data)
convolved = fft.irfft(wavelet_fft * data_fft)
```

**Rust 替代方案**:
- `rustfft`
- `ndarray` + FFT
- 自实现小波变换

---

## 关键数据结构

### 1. Raw (连续数据)
```python
class BaseRaw:
    _data: np.ndarray  # (n_channels, n_times)
    info: Info
    first_samp: int
    last_samp: int
```

**Rust 等价**:
```rust
struct Raw {
    data: Array2<f64>,  // ndarray
    info: Info,
    first_samp: usize,
    last_samp: usize,
}
```

### 2. Epochs (分段数据)
```python
class BaseEpochs:
    _data: np.ndarray  # (n_epochs, n_channels, n_times)
    events: np.ndarray  # (n_events, 3)
    event_id: dict
```

**Rust 等价**:
```rust
struct Epochs {
    data: Array3<f64>,
    events: Array2<i32>,
    event_id: HashMap<String, i32>,
}
```

### 3. Evoked (平均数据)
```python
class Evoked:
    data: np.ndarray  # (n_channels, n_times)
    nave: int  # 平均次数
```

### 4. SourceEstimate (源估计结果)
```python
class SourceEstimate:
    data: np.ndarray  # (n_vertices, n_times)
    vertices: list  # 顶点索引
    tmin: float
    tstep: float
```

---

## 性能瓶颈分析

基于 MNE-Python 的性能分析，主要瓶颈在：

### 1. 大数据量操作
- **问题**: Python GIL 限制多线程性能
- **影响模块**: I/O, 滤波, FFT
- **Rust 优势**: 无 GIL，真正并行

### 2. 循环密集计算
- **问题**: Python 循环慢
- **影响**: 自定义算法实现
- **Rust 优势**: 编译优化，零成本抽象

### 3. 内存复制
- **问题**: NumPy 数组传递涉及拷贝
- **Rust 优势**: 所有权系统，零拷贝

### 4. 类型检查
- **问题**: 运行时类型错误
- **Rust 优势**: 编译时类型检查

---

## Rust 生态对应表

| Python 库 | Rust Crate | 成熟度 | 备注 |
|-----------|-----------|--------|------|
| NumPy | `ndarray` | ⭐⭐⭐⭐⭐ | 成熟 |
| NumPy (linalg) | `ndarray-linalg` | ⭐⭐⭐⭐ | LAPACK 绑定 |
| SciPy (linalg) | `nalgebra`, `faer` | ⭐⭐⭐⭐ | 纯 Rust |
| SciPy (FFT) | `rustfft` | ⭐⭐⭐⭐⭐ | 高性能 |
| SciPy (signal) | `biquad`, `butter`, 自实现 | ⭐⭐⭐ | 需补充 |
| SciPy (sparse) | `sprs` | ⭐⭐⭐⭐ | 稀疏矩阵 |
| SciPy (stats) | `statrs` | ⭐⭐⭐⭐ | 统计函数 |
| SciPy (optimize) | `argmin` | ⭐⭐⭐ | 优化算法 |
| SciPy (interpolate) | `interp` | ⭐⭐⭐ | 插值 |
| scikit-learn | `smartcore`, `linfa` | ⭐⭐⭐ | 机器学习 |
| matplotlib | `plotters`, `polars` | ⁠⭐⭐⭐ | 可视化 |
| pandas | `polars` | ⭐⭐⭐⭐⭐ | DataFrame |
| h5py | `hdf5` | ⭐⭐⭐⭐ | HDF5 |

### 缺失功能评估

需要自行实现的模块：
1. **ICA** (独立成分分析)
   - FastICA 算法
   - Infomax 算法
   - Extended Infomax

2. **高级滤波器**
   - FIR 滤波器设计
   - Parks-McClellan 算法
   - Hilbert 变换

3. **信号处理**
   - STFT (短时傅里叶变换)
   - 小波变换
   - 时频分析

4. **源估计**
   - BEM 求解器
   - Leadfield 计算
   - 各种逆解算法

5. **统计检验**
   - 簇级别置换检验
   - 时空聚类
   - FDR 校正

---

## 下一步文档

本系列文档结构：

1. **00_依赖分析总览.md** (本文档) ✅
2. **01_NumPy依赖深度分析.md** - NumPy 具体使用细节
3. **02_SciPy依赖深度分析.md** - SciPy 各子模块分析
4. **03_scikit-learn依赖分析.md** - 机器学习组件
5. **04_其他依赖分析.md** - 可视化、数据格式等
6. **05_Rust替代方案架构.md** - 完整 Rust 架构设计
7. **06_核心算法Rust实现.md** - 关键算法移植
8. **07_重写路线图.md** - 分阶段实施计划

---

## 总结

### 依赖复杂度评估

| 依赖 | 使用广度 | 使用深度 | 替代难度 | 优先级 |
|------|---------|---------|---------|--------|
| NumPy 数组 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | 低 | P0 |
| NumPy linalg | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 低-中 | P0 |
| SciPy signal | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 中-高 | P0 |
| SciPy linalg | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 中 | P0 |
| SciPy sparse | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 中 | P1 |
| SciPy stats | ⭐⭐⭐ | ⭐⭐⭐ | 中 | P1 |
| sklearn | ⭐⭐⭐ | ⭐⭐⭐⭐ | 高 | P2 |

### 可行性评估

**✅ 高可行性**:
- 基础数组操作 (`ndarray`)
- 线性代数 (`ndarray-linalg`, `nalgebra`)
- FFT (`rustfft`)
- 数据 I/O (各格式库)

**⚠️ 中等可行性**:
- 信号处理 (部分需自实现)
- 统计函数 (`statrs` + 补充)
- 优化算法 (`argmin` + 补充)

**❌ 需大量开发**:
- ICA (完全自实现)
- 高级源估计算法
- 簇级别统计检验
- 复杂可视化

### 建议策略

1. **阶段 1**: 核心数据结构和 I/O (3个月)
2. **阶段 2**: 基础预处理 (滤波、重采样) (3个月)
3. **阶段 3**: ICA 和伪影去除 (4个月)
4. **阶段 4**: 源估计和统计 (6个月)
5. **阶段 5**: 可视化和工具链 (3个月)

**总估算**: 19个月核心开发 + 测试和优化

---

**继续阅读**: [01_NumPy依赖深度分析.md](01_NumPy依赖深度分析.md)
