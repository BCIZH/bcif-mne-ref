# MNE-Python 其他依赖分析

## 概述

除了 NumPy, SciPy, scikit-learn 这三大核心依赖，MNE-Python 还依赖多个辅助库用于可视化、数据I/O、并行计算等。本文档分析这些依赖及其 Rust 替代方案。

---

## 其他依赖清单

| 依赖库 | 用途 | 关键程度 | Rust 替代难度 |
|--------|------|---------|--------------|
| **matplotlib** | 数据可视化 | 高 | 高（用 plotters） |
| **pandas** | 数据表格处理 | 中 | 低（用 polars） |
| **h5py** | HDF5 文件I/O | 高 | 低（用 hdf5） |
| **nibabel** | 神经影像格式 | 高 | 中（FFI或移植） |
| **joblib** | 并行计算 | 中 | 低（用 rayon） |
| **tqdm** | 进度条 | 低 | 低（用 indicatif） |
| **decorator** | 装饰器工具 | 低 | 无需（宏实现） |
| **jinja2** | 模板引擎 | 低 | 低（用 tera） |
| **pooch** | 数据下载 | 低 | 低（用 reqwest） |
| **lazy_loader** | 延迟加载 | 低 | 无需 |

---

## 1. matplotlib - 数据可视化

### 1.1 MNE 中的使用

```python
import matplotlib.pyplot as plt
from matplotlib import patches

# 时间序列图
raw.plot(duration=10.0, scalings='auto')

# 地形图
evoked.plot_topomap(times=[0.1, 0.2, 0.3])

# 功率谱
raw.compute_psd().plot()

# 自定义绘图
fig, ax = plt.subplots()
ax.plot(times, data[0])
ax.set_xlabel('Time (s)')
ax.set_ylabel('Amplitude')
plt.show()
```

### 1.2 Rust 替代方案

#### 方案 1: plotters（推荐）

```toml
[dependencies]
plotters = "0.3"
```

```rust
use plotters::prelude::*;

fn plot_timeseries(times: &[f64], data: &Array1<f64>) -> Result<(), Box<dyn std::error::Error>> {
    let root = BitMapBackend::new("timeseries.png", (1024, 768)).into_drawing_area();
    root.fill(&WHITE)?;
    
    let mut chart = ChartBuilder::on(&root)
        .caption("EEG Time Series", ("Arial", 50))
        .margin(5)
        .x_label_area_size(30)
        .y_label_area_size(30)
        .build_cartesian_2d(
            times[0]..times[times.len()-1],
            *data.min().unwrap()..*data.max().unwrap()
        )?;
    
    chart.configure_mesh().draw()?;
    
    chart.draw_series(LineSeries::new(
        times.iter().zip(data.iter()).map(|(&t, &d)| (t, d)),
        &RED,
    ))?;
    
    root.present()?;
    Ok(())
}
```

#### 方案 2: egui + eframe（交互式）

```toml
[dependencies]
egui = "0.24"
eframe = "0.24"
```

```rust
use egui::*;

struct EEGViewer {
    data: Array2<f64>,
    times: Vec<f64>,
}

impl eframe::App for EEGViewer {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        egui::CentralPanel::default().show(ctx, |ui| {
            use egui::plot::{Line, Plot, PlotPoints};
            
            let line_data: PlotPoints = self.times.iter()
                .zip(self.data.row(0).iter())
                .map(|(&t, &d)| [t, d])
                .collect();
            
            let line = Line::new(line_data).color(Color32::RED);
            
            Plot::new("eeg_plot")
                .view_aspect(2.0)
                .show(ui, |plot_ui| plot_ui.line(line));
        });
    }
}
```

**关键差异**:
- matplotlib 功能更丰富
- Rust 可视化生态较不成熟
- plotters 适合静态图
- egui 适合交互式应用
- 可考虑输出 Web（wasm）+ JavaScript 可视化

---

## 2. pandas - 数据表格

### 2.1 MNE 中的使用

```python
import pandas as pd

# 转换为 DataFrame
df = epochs.to_data_frame()
print(df.head())

# 事件描述
events_df = pd.DataFrame(events, columns=['sample', 'prev', 'event_id'])

# 导出
df.to_csv('epochs_data.csv')
```

### 2.2 Rust 替代：polars（推荐）

```toml
[dependencies]
polars = { version = "0.35", features = ["lazy"] }
```

```rust
use polars::prelude::*;

fn epochs_to_dataframe(epochs: &Array3<f64>, ch_names: &[String]) -> Result<DataFrame> {
    let (n_epochs, n_channels, n_times) = epochs.dim();
    
    // 重塑数据
    let mut data_flat = Vec::new();
    let mut epoch_ids = Vec::new();
    let mut channel_ids = Vec::new();
    let mut time_ids = Vec::new();
    
    for epoch in 0..n_epochs {
        for ch in 0..n_channels {
            for time in 0..n_times {
                data_flat.push(epochs[[epoch, ch, time]]);
                epoch_ids.push(epoch as i32);
                channel_ids.push(ch_names[ch].clone());
                time_ids.push(time as i32);
            }
        }
    }
    
    let df = DataFrame::new(vec![
        Series::new("epoch", epoch_ids),
        Series::new("channel", channel_ids),
        Series::new("time", time_ids),
        Series::new("value", data_flat),
    ])?;
    
    Ok(df)
}

// 导出
df.write_csv("epochs_data.csv")?;
```

**优势**:
- polars 比 pandas 更快（尤其是大数据）
- 类似的 API
- 惰性求值支持
- 原生 Rust，无 Python 开销

---

## 3. h5py - HDF5 文件支持

### 3.1 MNE 中的使用

```python
import h5py

# 读取 HDF5
with h5py.File('data.h5', 'r') as f:
    data = f['epochs/data'][:]
    info = f['epochs/info'][()]

# 写入 HDF5
with h5py.File('output.h5', 'w') as f:
    f.create_dataset('data', data=epochs_data)
    f.create_dataset('times', data=times)
    f.attrs['sfreq'] = sfreq
```

### 3.2 Rust 替代：hdf5

```toml
[dependencies]
hdf5 = "0.8"
```

```rust
use hdf5::File;

fn write_hdf5(filename: &str, data: &Array3<f64>, sfreq: f64) -> hdf5::Result<()> {
    let file = File::create(filename)?;
    
    // 创建数据集
    let dataset = file.new_dataset::<f64>()
        .shape(data.shape())
        .create("epochs/data")?;
    dataset.write(data)?;
    
    // 写入属性
    dataset.attr("sfreq")?.write_scalar(&sfreq)?;
    
    Ok(())
}

fn read_hdf5(filename: &str) -> hdf5::Result<(Array3<f64>, f64)> {
    let file = File::open(filename)?;
    
    // 读取数据
    let dataset = file.dataset("epochs/data")?;
    let data: Array3<f64> = dataset.read()?;
    
    // 读取属性
    let sfreq: f64 = dataset.attr("sfreq")?.read_scalar()?;
    
    Ok((data, sfreq))
}
```

**优势**:
- Rust hdf5 crate 成熟
- API 类似 h5py
- 类型安全

---

## 4. nibabel - 神经影像格式

### 4.1 MNE 中的使用

```python
import nibabel as nib

# 读取 NIfTI
img = nib.load('T1.nii.gz')
data = img.get_fdata()
affine = img.affine

# 读取 FreeSurfer 表面
coords, faces = nib.freesurfer.read_geometry('lh.pial')

# 读取 GIFTI
gii = nib.load('surface.gii')
```

### 4.2 Rust 替代方案

#### 方案 1: 使用 FFI 绑定 nibabel

```rust
use pyo3::prelude::*;

fn read_nifti(filename: &str) -> PyResult<(Array3<f64>, Array2<f64>)> {
    Python::with_gil(|py| {
        let nib = py.import("nibabel")?;
        let img = nib.call_method1("load", (filename,))?;
        let data: Array3<f64> = img.call_method0("get_fdata")?.extract()?;
        let affine: Array2<f64> = img.getattr("affine")?.extract()?;
        Ok((data, affine))
    })
}
```

#### 方案 2: 移植核心功能

```rust
// 简化的 NIfTI 读取（需要实现完整的 NIfTI 规范）
use byteorder::{LittleEndian, ReadBytesExt};
use std::fs::File;
use std::io::Read;

struct NiftiHeader {
    dim: [u16; 8],
    datatype: u16,
    bitpix: u16,
    // ... 更多字段
}

fn read_nifti_simple(filename: &str) -> Result<Array3<f64>> {
    let mut file = File::open(filename)?;
    
    // 读取头部（348 字节）
    let mut header_bytes = vec![0u8; 348];
    file.read_exact(&mut header_bytes)?;
    
    // 解析头部...
    // 读取数据...
    
    todo!("需要完整实现 NIfTI 规范")
}
```

**建议**:
- 优先级较低时使用 FFI
- 如需纯 Rust，可能需要移植 nibabel 核心功能（工作量大）
- 考虑只实现 MNE 需要的格式子集

---

## 5. joblib - 并行计算和缓存

### 5.1 MNE 中的使用

```python
from joblib import Parallel, delayed

# 并行处理
results = Parallel(n_jobs=4)(
    delayed(process_epoch)(epoch) 
    for epoch in epochs
)

# 缓存
from joblib import Memory
memory = Memory('./cachedir')

@memory.cache
def expensive_function(data):
    # 耗时计算
    return result
```

### 5.2 Rust 替代：rayon

```toml
[dependencies]
rayon = "1.7"
```

```rust
use rayon::prelude::*;

// 并行处理
fn process_epochs_parallel(epochs: &[Array2<f64>]) -> Vec<ProcessedEpoch> {
    epochs.par_iter()
        .map(|epoch| process_epoch(epoch))
        .collect()
}

// 并行迭代器链
let results: Vec<_> = (0..1000)
    .into_par_iter()
    .map(|i| expensive_computation(i))
    .filter(|&x| x > threshold)
    .collect();
```

**缓存替代**:
```toml
[dependencies]
cached = "0.46"
```

```rust
use cached::proc_macro::cached;

#[cached]
fn expensive_function(data: Vec<f64>) -> Vec<f64> {
    // 耗时计算，自动缓存
    data.iter().map(|&x| x.powi(2)).collect()
}
```

**优势**:
- rayon 零成本并行抽象
- 比 joblib 更快（无 Python GIL）
- 工作窃取调度

---

## 6. tqdm - 进度条

### 6.1 MNE 中的使用

```python
from tqdm import tqdm

for epoch in tqdm(epochs, desc='Processing'):
    process(epoch)
```

### 6.2 Rust 替代：indicatif

```toml
[dependencies]
indicatif = "0.17"
```

```rust
use indicatif::{ProgressBar, ProgressStyle};

let pb = ProgressBar::new(epochs.len() as u64);
pb.set_style(
    ProgressStyle::default_bar()
        .template("[{elapsed_precise}] {bar:40.cyan/blue} {pos}/{len} {msg}")
        .unwrap()
);

for (i, epoch) in epochs.iter().enumerate() {
    process_epoch(epoch);
    pb.set_message(format!("Processing epoch {}", i));
    pb.inc(1);
}
pb.finish_with_message("Done!");
```

**优势**:
- 功能丰富（进度条、spinner）
- 支持多进度条
- 性能更好

---

## 7. jinja2 - 模板引擎（报告生成）

### 7.1 MNE 中的使用

```python
from jinja2 import Template

template = Template('''
<html>
  <h1>{{ title }}</h1>
  <p>Epochs: {{ n_epochs }}</p>
</html>
''')

html = template.render(title='Report', n_epochs=100)
```

### 7.2 Rust 替代：tera

```toml
[dependencies]
tera = "1.19"
```

```rust
use tera::{Context, Tera};

let mut tera = Tera::default();
tera.add_raw_template("report.html", r#"
<html>
  <h1>{{ title }}</h1>
  <p>Epochs: {{ n_epochs }}</p>
</html>
"#)?;

let mut context = Context::new();
context.insert("title", "Report");
context.insert("n_epochs", &100);

let html = tera.render("report.html", &context)?;
```

---

## 8. pooch - 数据下载管理

### 8.1 MNE 中的使用

```python
import pooch

file_path = pooch.retrieve(
    url="https://example.com/data.fif",
    known_hash="sha256:abc123...",
    path=pooch.os_cache("mne"),
)
```

### 8.2 Rust 替代：reqwest + sha2

```toml
[dependencies]
reqwest = { version = "0.11", features = ["blocking"] }
sha2 = "0.10"
dirs = "5.0"
```

```rust
use reqwest::blocking::get;
use sha2::{Sha256, Digest};
use std::fs::{self, File};
use std::io::Write;
use std::path::PathBuf;

fn download_with_hash(url: &str, expected_hash: &str) -> Result<PathBuf> {
    // 缓存目录
    let cache_dir = dirs::cache_dir()
        .unwrap()
        .join("mne-rust");
    fs::create_dir_all(&cache_dir)?;
    
    // 文件名
    let filename = url.split('/').last().unwrap();
    let filepath = cache_dir.join(filename);
    
    // 如果已存在且哈希匹配，直接返回
    if filepath.exists() {
        let content = fs::read(&filepath)?;
        let hash = format!("{:x}", Sha256::digest(&content));
        if hash == expected_hash {
            return Ok(filepath);
        }
    }
    
    // 下载
    println!("Downloading {}...", filename);
    let response = get(url)?;
    let bytes = response.bytes()?;
    
    // 验证哈希
    let hash = format!("{:x}", Sha256::digest(&bytes));
    if hash != expected_hash {
        return Err("Hash mismatch".into());
    }
    
    // 保存
    let mut file = File::create(&filepath)?;
    file.write_all(&bytes)?;
    
    Ok(filepath)
}
```

---

## 9. decorator - 装饰器工具

### 9.1 MNE 中的使用

```python
from mne.utils import verbose

@verbose
def my_function(data, verbose=None):
    logger.info('Processing...')
    return result
```

### 9.2 Rust 替代：过程宏

```rust
// 定义宏
use proc_macro::TokenStream;

#[proc_macro_attribute]
pub fn verbose(_attr: TokenStream, item: TokenStream) -> TokenStream {
    // 实现日志包装...
    item
}

// 使用
#[verbose]
fn my_function(data: &Array2<f64>) -> Array2<f64> {
    info!("Processing...");
    process(data)
}
```

或使用简单的 trait:

```rust
trait Verbose {
    fn with_logging<F, R>(&self, f: F) -> R
    where
        F: FnOnce() -> R;
}
```

---

## 10. 其他小型依赖

### 10.1 lazy_loader

Rust 中使用 `lazy_static` 或 `once_cell`:

```rust
use once_cell::sync::Lazy;

static EXPENSIVE_DATA: Lazy<Vec<f64>> = Lazy::new(|| {
    // 首次访问时加载
    load_expensive_data()
});
```

### 10.2 packaging（版本比较）

```rust
use semver::Version;

let v1 = Version::parse("1.2.3")?;
let v2 = Version::parse("1.3.0")?;
assert!(v1 < v2);
```

---

## Rust 替代方案总结

| Python 库 | Rust 替代 | 成熟度 | 备注 |
|-----------|-----------|--------|------|
| matplotlib | plotters / egui | ⭐⭐⭐ | 功能较少但足够 |
| pandas | polars | ⭐⭐⭐⭐⭐ | 更快更好 |
| h5py | hdf5 | ⭐⭐⭐⭐ | 成熟可用 |
| nibabel | 需移植/FFI | ⭐⭐ | 工作量大 |
| joblib | rayon | ⭐⭐⭐⭐⭐ | 性能优异 |
| tqdm | indicatif | ⭐⭐⭐⭐ | 功能丰富 |
| jinja2 | tera | ⭐⭐⭐⭐ | 可用 |
| pooch | reqwest + sha2 | ⭐⭐⭐⭐ | 易实现 |
| decorator | proc_macro | ⭐⭐⭐ | 更强大 |

---

## 可视化策略

### 方案 A: 纯 Rust 静态图（plotters）

**优点**:
- 无外部依赖
- 可嵌入应用
- 支持多种后端（PNG, SVG, HTML Canvas）

**缺点**:
- 功能不如 matplotlib 丰富
- 地形图等特殊图形需要自己实现

### 方案 B: Web 前端（推荐）

**架构**:
```
Rust 后端（计算）
    ↓ JSON/MessagePack
Web 前端（可视化）
    - Plotly.js
    - D3.js
    - ECharts
```

**实现**:
```rust
// Rust 后端生成数据
#[derive(Serialize)]
struct PlotData {
    times: Vec<f64>,
    channels: Vec<Vec<f64>>,
    channel_names: Vec<String>,
}

// 导出为 JSON
let data = PlotData { /* ... */ };
let json = serde_json::to_string(&data)?;

// 或启动 Web 服务器
use actix_web::{web, App, HttpServer};

#[actix_web::main]
async fn main() {
    HttpServer::new(|| {
        App::new()
            .route("/plot_data", web::get().to(get_plot_data))
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await?;
}
```

前端（HTML + JavaScript）:
```html
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<div id="plot"></div>
<script>
fetch('/plot_data')
  .then(r => r.json())
  .then(data => {
    const traces = data.channels.map((ch, i) => ({
      x: data.times,
      y: ch,
      name: data.channel_names[i],
      type: 'scatter'
    }));
    Plotly.newPlot('plot', traces);
  });
</script>
```

**优点**:
- 最强大的可视化（使用成熟的 JS 库）
- 交互性好
- 跨平台（浏览器）

**缺点**:
- 需要 Web 服务器
- 部署稍复杂

### 方案 C: 混合方案

核心计算用 Rust，可视化调用 Python matplotlib（通过 PyO3）：

```rust
use pyo3::prelude::*;

fn plot_with_matplotlib(data: &Array2<f64>, times: &[f64]) -> PyResult<()> {
    Python::with_gil(|py| {
        let plt = py.import("matplotlib.pyplot")?;
        
        plt.call_method1("plot", (times, data.row(0).to_vec(),))?;
        plt.call_method0("show")?;
        
        Ok(())
    })
}
```

---

## 文件格式支持

### 优先级列表

| 格式 | 重要性 | Rust 支持 |
|------|--------|-----------|
| **FIF** (MNE 原生) | P0 | 需实现 |
| **HDF5** (.h5) | P0 | ✅ hdf5 crate |
| **EDF/BDF** | P1 | 需实现 |
| **BrainVision** | P1 | 需实现 |
| **EEGLAB** (.set) | P1 | 需实现（基于 HDF5） |
| **NIfTI** | P2 | 考虑 FFI |
| **GIFTI** | P2 | 考虑 FFI |
| **FreeSurfer** | P2 | 需实现 |

### FIF 格式实现

FIF 是 FIFF (Functional Imaging File Format) 的 MNE 实现，需要自己实现：

```rust
// src/io/fif/mod.rs

use byteorder::{LittleEndian, ReadBytesExt};
use std::fs::File;
use std::io::{BufReader, Read, Seek};

const FIFF_FILE_ID: i32 = 100;
const FIFF_BLOCK_START: i32 = 104;
const FIFF_BLOCK_END: i32 = 105;

pub struct FifFile {
    file: BufReader<File>,
    tree: FifTree,
}

struct FifTree {
    id: i32,
    kind: i32,
    tags: Vec<FifTag>,
    children: Vec<FifTree>,
}

struct FifTag {
    kind: i32,
    type_: i32,
    size: i32,
    next: i32,
    data: Vec<u8>,
}

impl FifFile {
    pub fn open(filename: &str) -> Result<Self> {
        let file = File::open(filename)?;
        let mut reader = BufReader::new(file);
        
        // 读取文件树
        let tree = Self::read_tree(&mut reader)?;
        
        Ok(Self { file: reader, tree })
    }
    
    fn read_tree(reader: &mut BufReader<File>) -> Result<FifTree> {
        // 实现 FIFF 文件格式解析...
        todo!("需要完整实现 FIFF 规范")
    }
    
    pub fn read_raw_segment(&mut self, start: usize, stop: usize) -> Result<Array2<f64>> {
        // 读取原始数据段
        todo!()
    }
}
```

---

## 总结

### 已解决的依赖

1. ✅ **polars** 替代 pandas（性能更好）
2. ✅ **hdf5** 替代 h5py（成熟）
3. ✅ **rayon** 替代 joblib（更快）
4. ✅ **indicatif** 替代 tqdm
5. ✅ **tera** 替代 jinja2
6. ✅ **plotters/egui** 基础可视化

### 需要额外工作

1. ⚠️ **matplotlib** - 考虑 Web 前端方案
2. ⚠️ **nibabel** - FFI 或移植核心功能
3. ⚠️ **FIF 格式** - 必须自己实现

### 实现建议

**阶段 1**（基础设施）:
- [ ] HDF5 读写
- [ ] 基础可视化（plotters）
- [ ] 并行处理（rayon）

**阶段 2**（文件格式）:
- [ ] FIF 读写器
- [ ] EDF/BDF 支持
- [ ] BrainVision 支持

**阶段 3**（高级功能）:
- [ ] Web 可视化后端
- [ ] 神经影像格式（nibabel FFI 或移植）

继续阅读：[05_Rust替代方案架构.md](05_Rust替代方案架构.md)
