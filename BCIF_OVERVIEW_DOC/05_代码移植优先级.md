# MNE-Python åˆ° Rust ç§»æ¤ä¼˜å…ˆçº§å’Œè·¯çº¿å›¾

## æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾› MNE-Python åŠŸèƒ½åˆ° Rust çš„ç³»ç»Ÿæ€§ç§»æ¤è®¡åˆ’ï¼ŒåŒ…æ‹¬ï¼š
- åŠŸèƒ½ä¾èµ–å›¾
- ä¼˜å…ˆçº§è¯„ä¼°ï¼ˆP0-P3ï¼‰
- å®ç°éš¾åº¦è¯„ä¼°
- ä»£ç é‡ä¼°ç®—
- é‡Œç¨‹ç¢‘è§„åˆ’

---

## 1. ä¾èµ–å…³ç³»å›¾

```
æ ¸å¿ƒæ¨¡å—ä¾èµ–å…³ç³»ï¼š

Level 0 (åŸºç¡€è®¾æ–½)
â”œâ”€â”€ æ•°ç»„æ“ä½œ (ndarray)
â”œâ”€â”€ çº¿æ€§ä»£æ•° (ndarray-linalg)
â””â”€â”€ FFT (rustfft/realfft)

Level 1 (æ•°å­¦åŸºç¡€)
â”œâ”€â”€ æ»¤æ³¢å™¨è®¾è®¡ (è‡ªå®šä¹‰)
â”‚   â”œâ”€â”€ Butterworth
â”‚   â”œâ”€â”€ Chebyshev
â”‚   â””â”€â”€ FIR (windowed)
â”œâ”€â”€ ä¿¡å·å¤„ç†
â”‚   â”œâ”€â”€ é‡é‡‡æ ·
â”‚   â”œâ”€â”€ Hilbert å˜æ¢
â”‚   â””â”€â”€ æ»¤æ³¢åº”ç”¨ (filtfilt)
â””â”€â”€ ç»Ÿè®¡å‡½æ•° (statrs)

Level 2 (æ•°æ®ç»“æ„)
â”œâ”€â”€ Raw æ•°æ®ç»“æ„
â”‚   â”œâ”€â”€ é€šé“ä¿¡æ¯ (ChannelInfo)
â”‚   â”œâ”€â”€ æ—¶é—´ä¿¡æ¯ (Times)
â”‚   â””â”€â”€ äº‹ä»¶æ ‡è®° (Events)
â”œâ”€â”€ Epochs æ•°æ®ç»“æ„
â””â”€â”€ Evoked æ•°æ®ç»“æ„

Level 3 (é¢„å¤„ç†)
â”œâ”€â”€ æ»¤æ³¢ (ä¾èµ– Level 1)
â”œâ”€â”€ é‡å‚è€ƒ (ä¾èµ– Level 0)
â”œâ”€â”€ ä¼ªè¿¹å»é™¤
â”‚   â”œâ”€â”€ ICA (éœ€ç§»æ¤ FastICA)
â”‚   â””â”€â”€ SSP (ä¾èµ– Level 0)
â””â”€â”€ æ—¶é—´çª—å£ (Baseline, Cropping)

Level 4 (å‰å‘æ¨¡å‹)
â”œâ”€â”€ BEM (è¾¹ç•Œå…ƒæ¨¡å‹)
â”‚   â”œâ”€â”€ ç¨€ç–çŸ©é˜µ (sprs)
â”‚   â””â”€â”€ çº¿æ€§æ±‚è§£å™¨
â”œâ”€â”€ æºç©ºé—´ (SourceSpace)
â””â”€â”€ å¢ç›ŠçŸ©é˜µè®¡ç®—

Level 5 (é€†è§£)
â”œâ”€â”€ MNE (æœ€å°èŒƒæ•°ä¼°è®¡)
â”‚   â”œâ”€â”€ SVD
â”‚   â””â”€â”€ æ­£åˆ™åŒ–
â”œâ”€â”€ dSPM / sLORETA / eLORETA
â”œâ”€â”€ LCMV (Beamformer)
â””â”€â”€ MUSIC

Level 6 (æ—¶é¢‘åˆ†æ)
â”œâ”€â”€ çŸ­æ—¶å‚…é‡Œå¶å˜æ¢ (STFT)
â”œâ”€â”€ å°æ³¢å˜æ¢ (Wavelet)
â”œâ”€â”€ Morlet å˜æ¢
â””â”€â”€ åŠŸç‡è°±å¯†åº¦ (PSD)

Level 7 (è¿æ¥æ€§)
â”œâ”€â”€ ç›¸ä½é”å®šå€¼ (PLV)
â”œâ”€â”€ ç›¸å¹²æ€§ (Coherence)
â””â”€â”€ Granger å› æœ

Level 8 (è§£ç /æœºå™¨å­¦ä¹ )
â”œâ”€â”€ æ—¶é—´è§£ç 
â”‚   â”œâ”€â”€ PCA (linfa-pca)
â”‚   â”œâ”€â”€ SVM (smartcore)
â”‚   â””â”€â”€ é€»è¾‘å›å½’ (linfa-logistic)
â”œâ”€â”€ äº¤å‰éªŒè¯
â””â”€â”€ ç‰¹å¾é€‰æ‹©
```

---

## 2. ä¼˜å…ˆçº§çŸ©é˜µ

### 2.1 è¯„ä¼°æ ‡å‡†

**ä¼˜å…ˆçº§å› ç´ **:
1. **ä½¿ç”¨é¢‘ç‡** (1-5): ç”¨æˆ·ä½¿ç”¨è¯¥åŠŸèƒ½çš„é¢‘ç‡
2. **ä¾èµ–åº¦** (1-5): å…¶ä»–åŠŸèƒ½å¯¹è¯¥æ¨¡å—çš„ä¾èµ–ç¨‹åº¦
3. **å¤æ‚åº¦** (-5 to -1): å®ç°éš¾åº¦ï¼ˆè¶Šä½è¶Šéš¾ï¼‰
4. **ç°æœ‰ Rust æ”¯æŒ** (0-5): ç°æœ‰ crate çš„æˆç†Ÿåº¦

**ç»¼åˆå¾—åˆ†** = ä½¿ç”¨é¢‘ç‡ + ä¾èµ–åº¦ + å¤æ‚åº¦ + Rust æ”¯æŒ

**ä¼˜å…ˆçº§åˆ†ç±»**:
- **P0** (å¾—åˆ† â‰¥ 10): ç«‹å³å¼€å§‹ï¼Œæ ¸å¿ƒåŠŸèƒ½
- **P1** (å¾—åˆ† 7-9): ç¬¬ä¸€é˜¶æ®µï¼Œé«˜ä¼˜å…ˆçº§
- **P2** (å¾—åˆ† 4-6): ç¬¬äºŒé˜¶æ®µï¼Œä¸­ç­‰ä¼˜å…ˆçº§
- **P3** (å¾—åˆ† < 4): ç¬¬ä¸‰é˜¶æ®µï¼Œä½ä¼˜å…ˆçº§

---

### 2.2 åŠŸèƒ½ä¼˜å…ˆçº§è¡¨

| åŠŸèƒ½æ¨¡å— | ä½¿ç”¨é¢‘ç‡ | ä¾èµ–åº¦ | å¤æ‚åº¦ | Rustæ”¯æŒ | æ€»åˆ† | ä¼˜å…ˆçº§ | ä»£ç é‡ä¼°ç®— |
|---------|---------|--------|--------|---------|------|--------|-----------|
| **Level 0: åŸºç¡€è®¾æ–½** |
| æ•°ç»„æ“ä½œ (ndarray) | 5 | 5 | 0 | 5 | 15 | **P0** | 0 (ç°æˆ) |
| çº¿æ€§ä»£æ•° (linalg) | 5 | 5 | 0 | 4 | 14 | **P0** | 100 (å°è£…) |
| FFT (rustfft) | 5 | 4 | -1 | 4 | 12 | **P0** | 200 (rfftå°è£…) |
| **Level 1: æ•°å­¦åŸºç¡€** |
| Butterworth æ»¤æ³¢å™¨ | 5 | 4 | -3 | 1 | 7 | **P1** | 500 (ç§»æ¤) |
| FIR æ»¤æ³¢å™¨ | 4 | 3 | -2 | 2 | 7 | **P1** | 300 |
| æ»¤æ³¢åº”ç”¨ (filtfilt) | 5 | 4 | -2 | 2 | 9 | **P1** | 400 |
| é‡é‡‡æ · | 4 | 3 | -2 | 3 | 8 | **P1** | 300 |
| Hilbert å˜æ¢ | 3 | 2 | -1 | 3 | 7 | **P1** | 100 |
| **Level 2: æ•°æ®ç»“æ„** |
| Raw ç»“æ„ | 5 | 5 | -2 | 0 | 8 | **P1** | 1000 |
| Info ç»“æ„ | 5 | 5 | -1 | 0 | 9 | **P1** | 600 |
| Epochs ç»“æ„ | 5 | 4 | -2 | 0 | 7 | **P1** | 800 |
| Evoked ç»“æ„ | 4 | 3 | -1 | 0 | 6 | **P2** | 400 |
| **Level 3: é¢„å¤„ç†** |
| å¸¦é€šæ»¤æ³¢ | 5 | 4 | -1 | 0 | 8 | **P1** | 200 (ç»„åˆ) |
| é‡å‚è€ƒ | 5 | 3 | -1 | 0 | 7 | **P1** | 300 |
| ICA (FastICA) | 4 | 3 | -4 | 0 | 3 | **P2** | 1500 (ç§»æ¤) |
| SSP | 3 | 2 | -2 | 0 | 3 | **P2** | 500 |
| Baseline æ ¡æ­£ | 5 | 3 | 0 | 0 | 8 | **P1** | 100 |
| æ—¶é—´è£å‰ª | 5 | 2 | 0 | 0 | 7 | **P1** | 50 |
| **Level 4: å‰å‘æ¨¡å‹** |
| BEM æ±‚è§£ | 3 | 4 | -4 | 2 | 5 | **P2** | 2000 |
| æºç©ºé—´åˆ›å»º | 3 | 4 | -3 | 0 | 4 | **P2** | 1500 |
| å¢ç›ŠçŸ©é˜µ | 4 | 5 | -3 | 0 | 6 | **P2** | 1000 |
| **Level 5: é€†è§£** |
| MNE (æœ€å°èŒƒæ•°) | 5 | 4 | -3 | 0 | 6 | **P2** | 1200 |
| dSPM | 4 | 2 | -2 | 0 | 4 | **P2** | 400 |
| sLORETA | 3 | 2 | -3 | 0 | 2 | **P3** | 600 |
| eLORETA | 3 | 2 | -4 | 0 | 1 | **P3** | 800 |
| LCMV | 4 | 2 | -4 | 0 | 2 | **P3** | 1000 |
| **Level 6: æ—¶é¢‘åˆ†æ** |
| PSD (Welch) | 5 | 3 | -2 | 0 | 6 | **P2** | 400 |
| STFT | 4 | 3 | -1 | 0 | 6 | **P2** | 300 |
| Morlet å°æ³¢ | 3 | 2 | -3 | 0 | 2 | **P3** | 600 |
| Multitaper | 2 | 1 | -4 | 0 | -1 | **P3** | 800 |
| **Level 7: è¿æ¥æ€§** |
| PLV | 3 | 1 | -2 | 0 | 2 | **P3** | 300 |
| ç›¸å¹²æ€§ | 3 | 1 | -2 | 0 | 2 | **P3** | 400 |
| Granger å› æœ | 2 | 1 | -4 | 0 | -1 | **P3** | 1000 |
| **Level 8: æœºå™¨å­¦ä¹ ** |
| PCA | 3 | 2 | 0 | 4 | 9 | **P1** | 50 (linfa) |
| äº¤å‰éªŒè¯ | 4 | 2 | -1 | 3 | 8 | **P1** | 400 |
| SVM | 2 | 1 | 0 | 3 | 6 | **P2** | 100 (smartcore) |
| é€»è¾‘å›å½’ | 3 | 1 | 0 | 3 | 7 | **P1** | 100 (linfa) |
| **æ€»è®¡** | | | | | | | **~20,000 è¡Œ** |

---

## 3. é‡Œç¨‹ç¢‘è§„åˆ’

### Milestone 1: åŸºç¡€è®¾æ–½ (P0) - 2-3 å‘¨

**ç›®æ ‡**: å»ºç«‹æ ¸å¿ƒæ•°å­¦åŸºç¡€

**ä»»åŠ¡**:
1. âœ… é¡¹ç›®åˆå§‹åŒ–
   - Cargo workspace è®¾ç½®
   - ä¾èµ–é…ç½® (ndarray, ndarray-linalg, rustfft)
   - CI/CD è®¾ç½®

2. ğŸ”§ æ•°ç»„æ“ä½œå°è£… (~100 è¡Œ)
   ```rust
   // src/array/mod.rs
   pub use ndarray::*;
   
   // ä¾¿åˆ©å‡½æ•°
   pub fn zeros_2d(nrows: usize, ncols: usize) -> Array2<f64> { ... }
   pub fn linspace(start: f64, end: f64, n: usize) -> Array1<f64> { ... }
   ```

3. ğŸ”§ çº¿æ€§ä»£æ•°å°è£… (~100 è¡Œ)
   ```rust
   // src/linalg/mod.rs
   pub use ndarray_linalg::*;
   
   pub fn pinv(A: &Array2<f64>, rcond: f64) -> Result<Array2<f64>> { ... }
   pub fn safe_svd(A: &Array2<f64>) -> Result<(Array2<f64>, Array1<f64>, Array2<f64>)> { ... }
   ```

4. ğŸ”§ å®æ•° FFT å°è£… (~200 è¡Œ)
   ```rust
   // src/fft/mod.rs
   pub fn rfft(data: &Array1<f64>) -> Result<Array1<Complex<f64>>> { ... }
   pub fn irfft(spectrum: &Array1<Complex<f64>>, n: usize) -> Result<Array1<f64>> { ... }
   pub fn rfftfreq(n: usize, d: f64) -> Array1<f64> { ... }
   ```

**éªŒæ”¶æ ‡å‡†**:
- [ ] æ‰€æœ‰åŸºç¡€æ•°å­¦æ“ä½œé€šè¿‡å•å…ƒæµ‹è¯•
- [ ] FFT ä¸ NumPy ç»“æœä¸€è‡´ï¼ˆè¯¯å·® < 1e-10ï¼‰
- [ ] æ€§èƒ½åŸºå‡†ï¼šSVD é€Ÿåº¦ â‰¥ NumPy/SciPy 80%

---

### Milestone 2: ä¿¡å·å¤„ç†æ ¸å¿ƒ (P1) - 4-5 å‘¨

**ç›®æ ‡**: å®ç°æ»¤æ³¢å’Œé‡é‡‡æ ·

**ä»»åŠ¡**:
1. ğŸ”§ Butterworth æ»¤æ³¢å™¨è®¾è®¡ (~500 è¡Œ)
   - ç§»æ¤ `scipy.signal.butter`
   - å®ç° `buttap` (æ¨¡æ‹ŸåŸå‹)
   - å®ç° `bilinear` (åŒçº¿æ€§å˜æ¢)
   - å®ç° `zpk2sos` (é›¶æç‚¹ â†’ äºŒé˜¶èŠ‚)

   ```rust
   // src/filter/design.rs
   pub fn butter(
       order: usize,
       cutoff: f64,
       fs: f64,
       btype: FilterType
   ) -> Result<Array2<f64>> {  // SOS æ ¼å¼
       // ...
   }
   ```

2. ğŸ”§ FIR æ»¤æ³¢å™¨è®¾è®¡ (~300 è¡Œ)
   ```rust
   // src/filter/fir.rs
   pub fn firwin(
       numtaps: usize,
       cutoff: f64,
       window: WindowType,
       fs: f64
   ) -> Result<Array1<f64>> {
       // ...
   }
   ```

3. ğŸ”§ æ»¤æ³¢åº”ç”¨ (filtfilt) (~400 è¡Œ)
   ```rust
   // src/filter/apply.rs
   pub fn sosfiltfilt(
       sos: &Array2<f64>,
       x: &Array1<f64>,
       padlen: Option<usize>
   ) -> Result<Array1<f64>> {
       // 1. Pad
       // 2. Forward filter
       // 3. Reverse
       // 4. Backward filter
       // 5. Reverse
       // 6. Unpad
   }
   ```

4. ğŸ”§ é‡é‡‡æ · (~300 è¡Œ)
   ```rust
   // src/signal/resample.rs
   pub fn resample(
       x: &Array1<f64>,
       num: usize
   ) -> Result<Array1<f64>> {
       // FFT-based resampling
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- [ ] Butterworth 4 é˜¶æ»¤æ³¢å™¨ç³»æ•°ä¸ SciPy å®Œå…¨ä¸€è‡´
- [ ] filtfilt ç»“æœä¸ SciPy è¯¯å·® < 1e-8
- [ ] é‡é‡‡æ ·ä¿æŒä¿¡å·èƒ½é‡ï¼ˆè¯¯å·® < 1%ï¼‰

---

### Milestone 3: æ•°æ®ç»“æ„ (P1) - 3-4 å‘¨

**ç›®æ ‡**: å®ç°æ ¸å¿ƒæ•°æ®å®¹å™¨

**ä»»åŠ¡**:
1. ğŸ”§ é€šé“ä¿¡æ¯ (Info) (~600 è¡Œ)
   ```rust
   // src/io/info.rs
   pub struct Info {
       pub sfreq: f64,
       pub channels: Vec<ChannelInfo>,
       pub highpass: Option<f64>,
       pub lowpass: Option<f64>,
       // ...
   }
   
   pub struct ChannelInfo {
       pub name: String,
       pub kind: ChannelType,
       pub unit: Unit,
       pub loc: Array1<f64>,  // 12 å…ƒç´ 
       // ...
   }
   ```

2. ğŸ”§ Raw æ•°æ®ç»“æ„ (~1000 è¡Œ)
   ```rust
   // src/io/raw.rs
   pub struct Raw {
       info: Info,
       data: Array2<f64>,  // (n_channels, n_samples)
       times: Array1<f64>,
       first_samp: usize,
       last_samp: usize,
   }
   
   impl Raw {
       pub fn new(data: Array2<f64>, info: Info) -> Self { ... }
       
       pub fn filter(&mut self, l_freq: Option<f64>, h_freq: Option<f64>) -> Result<()> { ... }
       
       pub fn resample(&mut self, sfreq: f64) -> Result<()> { ... }
       
       pub fn get_data(&self, start: Option<usize>, stop: Option<usize>) -> ArrayView2<f64> { ... }
   }
   ```

3. ğŸ”§ Epochs æ•°æ®ç»“æ„ (~800 è¡Œ)
   ```rust
   // src/epochs/mod.rs
   pub struct Epochs {
       info: Info,
       data: Array3<f64>,  // (n_epochs, n_channels, n_times)
       events: Array2<i32>,  // (n_events, 3)
       event_id: HashMap<String, i32>,
       tmin: f64,
       tmax: f64,
   }
   
   impl Epochs {
       pub fn from_raw(
           raw: &Raw,
           events: &Array2<i32>,
           event_id: HashMap<String, i32>,
           tmin: f64,
           tmax: f64
       ) -> Result<Self> { ... }
       
       pub fn average(&self) -> Result<Evoked> { ... }
       
       pub fn apply_baseline(&mut self, baseline: (Option<f64>, Option<f64>)) -> Result<()> { ... }
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- [ ] èƒ½å¤Ÿè¯»å–æ¨¡æ‹Ÿ FIF æ ¼å¼æ•°æ®
- [ ] Raw.filter() ä¸ MNE-Python ç»“æœä¸€è‡´
- [ ] Epochs åˆ‡å‰²æ­£ç¡®ï¼ˆä¸ Python ç‰ˆæœ¬æ—¶é—´å¯¹é½ï¼‰

---

### Milestone 4: é¢„å¤„ç†æµæ°´çº¿ (P1-P2) - 4-5 å‘¨

**ç›®æ ‡**: å®Œæ•´çš„æ•°æ®é¢„å¤„ç†

**ä»»åŠ¡**:
1. ğŸ”§ é‡å‚è€ƒ (~300 è¡Œ)
   ```rust
   // src/preprocessing/reference.rs
   pub fn set_eeg_reference(
       raw: &mut Raw,
       ref_channels: Option<Vec<&str>>
   ) -> Result<()> {
       // å¹³å‡å‚è€ƒï¼šdata -= mean(data, axis=0)
       // æˆ–é€‰æ‹©å‚è€ƒé€šé“
   }
   ```

2. ğŸ”§ Baseline æ ¡æ­£ (~100 è¡Œ)
   ```rust
   // src/epochs/baseline.rs
   pub fn apply_baseline(
       data: &mut Array3<f64>,
       times: &Array1<f64>,
       baseline: (Option<f64>, Option<f64>),
       mode: BaselineMode
   ) -> Result<()> {
       // mode: Mean, Ratio, Percent, Zscore
   }
   ```

3. ğŸ”§ SSP (ä¿¡å·ç©ºé—´æŠ•å½±) (~500 è¡Œ)
   ```rust
   // src/preprocessing/ssp.rs
   pub fn compute_proj_eog(
       raw: &Raw,
       n_eog: Option<usize>
   ) -> Result<Vec<Projection>> {
       // åŸºäº PCA çš„æŠ•å½±å‘é‡
   }
   
   pub fn apply_proj(
       data: &mut Array2<f64>,
       projs: &[Projection]
   ) -> Result<()> {
       // data = (I - P) @ data
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- [ ] é‡å‚è€ƒåä¿¡å·å‡å€¼ä¸ºé›¶
- [ ] Baseline æ ¡æ­£ä¸ MNE-Python ä¸€è‡´
- [ ] SSP æŠ•å½±å EOG ä¼ªè¿¹é™ä½ > 70%

---

### Milestone 5: ICA ä¼ªè¿¹å»é™¤ (P2) - 5-6 å‘¨

**ç›®æ ‡**: ç§»æ¤ FastICA ç®—æ³•

**ä»»åŠ¡**:
1. ğŸ”§ æ•°æ®ç™½åŒ– (~200 è¡Œ)
   ```rust
   // src/preprocessing/ica/whiten.rs
   pub fn whiten(X: &Array2<f64>) -> Result<(Array2<f64>, Array2<f64>)> {
       // åŸºäº PCA/SVD çš„ç™½åŒ–
       // è¿”å›ï¼š(ç™½åŒ–æ•°æ®, ç™½åŒ–çŸ©é˜µ)
   }
   ```

2. ğŸ”§ FastICA æ ¸å¿ƒç®—æ³• (~600 è¡Œ)
   ```rust
   // src/preprocessing/ica/fastica.rs
   pub struct FastICA {
       n_components: usize,
       algorithm: ICAAlgorithm,  // Parallel / Deflation
       fun: ContrastFunction,    // Logcosh / Exp / Cube
       max_iter: usize,
       tol: f64,
       // æ‹Ÿåˆç»“æœ
       pub components: Option<Array2<f64>>,
       pub mixing: Option<Array2<f64>>,
   }
   
   impl FastICA {
       pub fn fit(&mut self, X: &Array2<f64>) -> Result<()> {
           // 1. ç™½åŒ–
           let (X_white, K) = whiten(X)?;
           
           // 2. FastICA è¿­ä»£
           let W = match self.algorithm {
               ICAAlgorithm::Parallel => self.ica_par(&X_white)?,
               ICAAlgorithm::Deflation => self.ica_def(&X_white)?,
           };
           
           // 3. ä¿å­˜è§£æ··çŸ©é˜µ
           self.components = Some(W.dot(&K));
           self.mixing = Some(pinv(&self.components.as_ref().unwrap(), 1e-15)?);
           
           Ok(())
       }
       
       fn ica_par(&self, X: &Array2<f64>) -> Result<Array2<f64>> {
           // å¹¶è¡Œ FastICA
       }
       
       fn ica_def(&self, X: &Array2<f64>) -> Result<Array2<f64>> {
           // deflation FastICA
       }
   }
   ```

3. ğŸ”§ ICA åº”ç”¨æ¥å£ (~700 è¡Œ)
   ```rust
   // src/preprocessing/ica/mod.rs
   pub struct ICA {
       n_components: usize,
       method: String,  // "fastica", "infomax", "picard"
       fit_params: HashMap<String, Value>,
       
       // æ‹Ÿåˆç»“æœ
       pub unmixing_matrix_: Option<Array2<f64>>,
       pub mixing_matrix_: Option<Array2<f64>>,
       pub exclude: Vec<usize>,  // è¦æ’é™¤çš„æˆåˆ†
   }
   
   impl ICA {
       pub fn fit(&mut self, raw: &Raw) -> Result<()> { ... }
       
       pub fn get_sources(&self, raw: &Raw) -> Result<Raw> {
           // S = W @ data
       }
       
       pub fn find_bads_eog(&mut self, raw: &Raw) -> Result<Vec<usize>> {
           // æŸ¥æ‰¾ä¸ EOG ç›¸å…³çš„æˆåˆ†
       }
       
       pub fn apply(&self, raw: &mut Raw) -> Result<()> {
           // é‡å»ºæ—¶æ’é™¤åæˆåˆ†
           // data = A @ S (S ä¸­åæˆåˆ†ç½®é›¶)
       }
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- [ ] FastICA æ”¶æ•›ï¼ˆä¸ sklearn ç›¸åŒè¿­ä»£æ¬¡æ•°ï¼‰
- [ ] åˆ†ç¦»çš„æˆåˆ†ä¸ sklearn ç›¸å…³æ€§ > 0.95
- [ ] EOG ä¼ªè¿¹å»é™¤æ•ˆæœä¸ MNE-Python ä¸€è‡´

---

### Milestone 6: å‰å‘æ¨¡å‹å’Œé€†è§£ (P2) - 6-8 å‘¨

**ç›®æ ‡**: æºä¼°è®¡æ ¸å¿ƒåŠŸèƒ½

**ä»»åŠ¡**:
1. ğŸ”§ æºç©ºé—´ (~1500 è¡Œ)
   ```rust
   // src/source_space/mod.rs
   pub struct SourceSpace {
       pub kind: SourceSpaceKind,  // Surface / Volume
       pub vertices: Array2<f64>,
       pub normals: Array2<f64>,
       pub tris: Array2<usize>,
       // ...
   }
   
   impl SourceSpace {
       pub fn from_surfaces(surfaces: Vec<Surface>) -> Result<Self> { ... }
       
       pub fn decimate(self, target_vertices: usize) -> Result<Self> { ... }
   }
   ```

2. ğŸ”§ BEM æ±‚è§£ (~2000 è¡Œ)
   ```rust
   // src/bem/mod.rs
   pub struct BEMSolution {
       pub solution: Array2<f64>,
       pub surfaces: Vec<Surface>,
   }
   
   pub fn make_bem_solution(
       surfaces: Vec<Surface>,
       conductivity: Vec<f64>
   ) -> Result<BEMSolution> {
       // è¾¹ç•Œå…ƒæ³•æ±‚è§£
       // ç¨€ç–çº¿æ€§ç³»ç»Ÿ
   }
   ```

3. ğŸ”§ å‰å‘è§£ç®—å­ (~1000 è¡Œ)
   ```rust
   // src/forward/mod.rs
   pub struct Forward {
       pub sol: Array2<f64>,  // å‰å‘è§£ (n_channels, n_sources*3)
       pub source_nn: Array2<f64>,
       pub source_rr: Array2<f64>,
       // ...
   }
   
   pub fn make_forward_solution(
       info: &Info,
       trans: &Transform,
       src: &SourceSpace,
       bem: &BEMSolution
   ) -> Result<Forward> {
       // è®¡ç®—å¢ç›ŠçŸ©é˜µ
   }
   ```

4. ğŸ”§ MNE é€†è§£ (~1200 è¡Œ)
   ```rust
   // src/minimum_norm/inverse.rs
   pub struct InverseOperator {
       pub eigen_leads: Array2<f64>,
       pub eigen_fields: Array2<f64>,
       pub sing: Array1<f64>,
       // ...
   }
   
   pub fn make_inverse_operator(
       info: &Info,
       forward: &Forward,
       noise_cov: &Covariance,
       loose: f64,
       depth: f64
   ) -> Result<InverseOperator> {
       // SVD-based inverse
   }
   
   pub fn apply_inverse(
       evoked: &Evoked,
       inv: &InverseOperator,
       lambda2: f64,
       method: &str  // "MNE", "dSPM", "sLORETA"
   ) -> Result<SourceEstimate> {
       // åº”ç”¨é€†ç®—å­
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- [ ] å¢ç›ŠçŸ©é˜µä¸ MNE-Python è¯¯å·® < 1e-6
- [ ] MNE æºä¼°è®¡ç©ºé—´ç›¸å…³æ€§ > 0.99
- [ ] dSPM ä¸ Python ç‰ˆæœ¬å®šä½è¯¯å·® < 5mm

---

### Milestone 7: æ—¶é¢‘åˆ†æ (P2) - 3-4 å‘¨

**ç›®æ ‡**: åŸºç¡€æ—¶é¢‘å·¥å…·

**ä»»åŠ¡**:
1. ğŸ”§ åŠŸç‡è°±å¯†åº¦ (~400 è¡Œ)
   ```rust
   // src/time_frequency/psd.rs
   pub fn psd_welch(
       data: &Array2<f64>,
       sfreq: f64,
       n_fft: Option<usize>,
       n_overlap: Option<usize>
   ) -> Result<(Array1<f64>, Array2<f64>)> {
       // Welch æ–¹æ³•
       // è¿”å›ï¼š(é¢‘ç‡, PSD)
   }
   ```

2. ğŸ”§ çŸ­æ—¶å‚…é‡Œå¶å˜æ¢ (~300 è¡Œ)
   ```rust
   // src/time_frequency/stft.rs
   pub fn stft(
       x: &Array1<f64>,
       n_fft: usize,
       hop_length: usize,
       window: WindowType
   ) -> Result<Array2<Complex<f64>>> {
       // è¿”å›ï¼š(n_freqs, n_frames)
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- [ ] Welch PSD ä¸ SciPy è¯¯å·® < 1%
- [ ] STFT ç›¸ä½ä¸æŒ¯å¹…æ­£ç¡®

---

### Milestone 8: æœºå™¨å­¦ä¹ é›†æˆ (P1-P2) - 2-3 å‘¨

**ç›®æ ‡**: è§£ç å’Œåˆ†ç±»

**ä»»åŠ¡**:
1. ğŸ”§ äº¤å‰éªŒè¯ (~400 è¡Œ)
   ```rust
   // src/decoding/cv.rs
   pub fn cross_val_score<M: Classifier>(
       model: &M,
       X: &Array2<f64>,
       y: &Array1<i32>,
       cv: usize
   ) -> Result<Array1<f64>> {
       // K-Fold äº¤å‰éªŒè¯
   }
   ```

2. ğŸ”§ é›†æˆ linfa å’Œ smartcore (~200 è¡Œ)
   ```rust
   // src/decoding/classifiers.rs
   pub use linfa_logistic::LogisticRegression;
   pub use linfa_pca::Pca;
   pub use smartcore::svm::SVC;
   ```

**éªŒæ”¶æ ‡å‡†**:
- [ ] äº¤å‰éªŒè¯åˆ†æ•°ä¸ sklearn ä¸€è‡´
- [ ] PCA ä¸»æˆåˆ†æ–¹å·®è§£é‡Šç‡åŒ¹é…

---

## 4. ä»£ç é‡æ€»ç»“

| é˜¶æ®µ | æ¨¡å— | ä»£ç é‡ (è¡Œ) | å·¥æ—¶ä¼°ç®— (å‘¨) |
|-----|------|-----------|--------------|
| M1 | åŸºç¡€è®¾æ–½ | 400 | 2-3 |
| M2 | ä¿¡å·å¤„ç† | 1500 | 4-5 |
| M3 | æ•°æ®ç»“æ„ | 2400 | 3-4 |
| M4 | é¢„å¤„ç† | 900 | 4-5 |
| M5 | ICA | 1500 | 5-6 |
| M6 | å‰å‘/é€†è§£ | 5700 | 6-8 |
| M7 | æ—¶é¢‘åˆ†æ | 700 | 3-4 |
| M8 | æœºå™¨å­¦ä¹  | 600 | 2-3 |
| **æ€»è®¡** | | **~13,700** | **29-38 å‘¨** |

**æ³¨æ„**: ä¸åŒ…æ‹¬æµ‹è¯•ä»£ç ï¼ˆé¢„è®¡é¢å¤– 50%ï¼‰å’Œæ–‡æ¡£ï¼ˆé¢å¤– 20%ï¼‰

---

## 5. é£é™©è¯„ä¼°

### é«˜é£é™©é¡¹

1. **ICA ç®—æ³•ç§»æ¤** (M5)
   - **é£é™©**: FastICA æ”¶æ•›æ€§é—®é¢˜
   - **ç¼“è§£**: è¯¦ç»†å¯¹æ¯”æ¯æ¬¡è¿­ä»£çš„ä¸­é—´ç»“æœ
   - **å¤‡é€‰**: è°ƒç”¨ Python sklearn (PyO3)

2. **BEM æ±‚è§£å™¨** (M6)
   - **é£é™©**: ç¨€ç–çº¿æ€§ç³»ç»Ÿæ±‚è§£æ€§èƒ½
   - **ç¼“è§£**: ä½¿ç”¨ sprs + pardiso/MUMPS
   - **å¤‡é€‰**: é¢„è®¡ç®— BEM è§£

3. **æ»¤æ³¢å™¨æ•°å€¼ç¨³å®šæ€§** (M2)
   - **é£é™©**: é«˜é˜¶ IIR æ»¤æ³¢å™¨æŒ¯è¡
   - **ç¼“è§£**: å¼ºåˆ¶ä½¿ç”¨ SOS (äºŒé˜¶èŠ‚) æ ¼å¼
   - **å¤‡é€‰**: ä½¿ç”¨ FIR æ»¤æ³¢å™¨

### ä¸­é£é™©é¡¹

1. **æ€§èƒ½ä¼˜åŒ–**
   - **é£é™©**: Rust ç‰ˆæœ¬æ¯” Python æ…¢
   - **ç¼“è§£**: åˆ†æçƒ­ç‚¹ï¼Œä½¿ç”¨ SIMD/å¹¶è¡Œ

2. **å†…å­˜ç®¡ç†**
   - **é£é™©**: å¤§æ•°æ®é›†å†…å­˜æº¢å‡º
   - **ç¼“è§£**: æµå¼å¤„ç†ï¼Œå†…å­˜æ˜ å°„æ–‡ä»¶

---

## 6. æµ‹è¯•ç­–ç•¥

### å•å…ƒæµ‹è¯•
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use approx::assert_abs_diff_eq;
    
    #[test]
    fn test_butter_coefficients() {
        let sos = butter(4, 40.0, 1000.0, FilterType::LowPass).unwrap();
        
        // ä¸ scipy.signal.butter ç»“æœå¯¹æ¯”
        let expected = array![
            [0.0009, 0.0018, 0.0009, 1.0, -1.8832, 0.8872],
            [1.0, 2.0, 1.0, 1.0, -1.9726, 0.9735]
        ];
        
        assert_abs_diff_eq!(sos, expected, epsilon = 1e-4);
    }
}
```

### é›†æˆæµ‹è¯•
```rust
#[test]
fn test_preprocessing_pipeline() {
    let mut raw = Raw::from_file("sample_audvis_raw.fif").unwrap();
    
    // æ»¤æ³¢
    raw.filter(Some(1.0), Some(40.0)).unwrap();
    
    // é‡å‚è€ƒ
    raw.set_eeg_reference(None).unwrap();  // å¹³å‡å‚è€ƒ
    
    // ICA
    let mut ica = ICA::new(20);
    ica.fit(&raw).unwrap();
    let bad_ics = ica.find_bads_eog(&raw).unwrap();
    ica.exclude = bad_ics;
    ica.apply(&mut raw).unwrap();
    
    // éªŒè¯ç»“æœ
    assert!(raw.info.highpass == Some(1.0));
    assert!(raw.info.lowpass == Some(40.0));
}
```

### æ€§èƒ½åŸºå‡†
```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn bench_filtfilt(c: &mut Criterion) {
    let sos = butter(4, 40.0, 1000.0, FilterType::LowPass).unwrap();
    let data = Array1::random(100000, StandardNormal);
    
    c.bench_function("filtfilt 100k samples", |b| {
        b.iter(|| {
            sosfiltfilt(black_box(&sos), black_box(&data), Some(100))
        })
    });
}

criterion_group!(benches, bench_filtfilt);
criterion_main!(benches);
```

---

## 7. ä¸‹ä¸€æ­¥è¡ŒåŠ¨

### ç«‹å³å¼€å§‹ (æœ¬å‘¨)
1. [ ] åˆ›å»º Cargo workspace
2. [ ] é…ç½®ä¾èµ– (ndarray, ndarray-linalg, rustfft)
3. [ ] å®ç°åŸºç¡€æ•°ç»„å°è£…
4. [ ] ç¼–å†™ FFT å°è£…å’Œæµ‹è¯•

### è¿‘æœŸ (2-4 å‘¨)
1. [ ] ç§»æ¤ Butterworth æ»¤æ³¢å™¨è®¾è®¡
2. [ ] å®ç° filtfilt
3. [ ] å¼€å§‹ Raw æ•°æ®ç»“æ„

### ä¸­æœŸ (1-3 ä¸ªæœˆ)
1. [ ] å®Œæˆé¢„å¤„ç†æµæ°´çº¿
2. [ ] ç§»æ¤ FastICA
3. [ ] å®ç°å‰å‘/é€†è§£åŸºç¡€ç‰ˆæœ¬

### é•¿æœŸ (3-6 ä¸ªæœˆ)
1. [ ] å®Œæ•´çš„æºä¼°è®¡å·¥å…·é“¾
2. [ ] æ—¶é¢‘åˆ†ææ¨¡å—
3. [ ] æ€§èƒ½ä¼˜åŒ–å’Œå¹¶è¡ŒåŒ–

---

## é™„å½•ï¼šå‚è€ƒèµ„æº

### å…³é”® Python æºç 
- `scipy/signal/_filter_design.py` - æ»¤æ³¢å™¨è®¾è®¡
- `scipy/signal/_signaltools.py` - filtfilt, resample
- `sklearn/decomposition/_fastica.py` - FastICA
- `mne/preprocessing/ica.py` - ICA åº”ç”¨
- `mne/minimum_norm/inverse.py` - é€†è§£ç®—å­

### Rust Crates
- **ndarray**: https://docs.rs/ndarray
- **ndarray-linalg**: https://docs.rs/ndarray-linalg
- **rustfft**: https://docs.rs/rustfft
- **sprs**: https://docs.rs/sprs
- **linfa**: https://rust-ml.github.io/linfa/
- **smartcore**: https://smartcorelib.org/

### æ•°å­¦å‚è€ƒ
- *Butterworth Filter Design*: [DSP Guide Chapter 20]
- *FastICA Algorithm*: HyvÃ¤rinen & Oja (2000)
- *MNE Inverse Solution*: HÃ¤mÃ¤lÃ¤inen & Ilmoniemi (1994)
